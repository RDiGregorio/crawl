# DCSS 0.26

# use the c_message hook instead of searching last message!
# handle oklob plant
# handle shops: items.shop_inventory() and items.shopping_list()
# script wand usage on eels, some blinkers
# script special tactics for certain monsters
# need to add checks for safe and automatically trigger it
# prevent running in some cases (berserk, slow, poisoned?)
# prevent running if some fast mobs are adjacent?

# escape logic needs a LOT of work
# can macro the escape key to get around paralysis force more
# scroll of identify is buggy when you have artifacts
# ring logic is buggy, trying to equip rings you are already wearing
# can walk into travel exclusions while tabbing

# add logic to bia when piety > 4
# improve logic for when you can't reach an electric eel
# run on torment
# add hallway preference, improve the can escape logic

# stop running should take an argument to print why

-------------------------------------------------------------------------
-- options                                                             --
-------------------------------------------------------------------------

bindkey = [s] CMD_NO_CMD_DEFAULT
bindkey = [p] CMD_NO_CMD_DEFAULT

view_delay = 0
travel_delay = -1
rest_delay = -1
use_animations = hp

travel_key_stop = false
show_travel_trail = false
explore_auto_rest = true
rest_wait_both = true
show_more = false
easy_confirm = all
autofight_stop = 0
autofight_caught = true
travel_one_unsafe_move = true

explore_stop = stairs, shops, altars, portals, branches, runed_doors
explore_stop += greedy_pickup

#autopickup_exceptions += brilliance, holy word, silence
#autopickup_exceptions += polymorph, random effects

autopickup_exceptions += <phantom mirror, <throwing net, <dart

auto_exclude = oklob plant, Roxanne, orange crystal statue, diamond obelisk

channel.intrinsic_gain = mute
channel.god = mute
channel.multiturn = mute
channel.talk = mute
channel.talk_visual = mute
channel.timed_portal = mute
cannel.sound = mute
channel.monster_damage = mute

message_colour += mute:menu to convert
message_colour += mute:Move the cursor to view the level map
message_colour += mute:Returning to the game
message_colour += mute:Waypoint 0

species = ho
background = be
weapon = hand axe
default_manual_training = true

---------------------------------------------------------------------------
-- main                                                                  --
---------------------------------------------------------------------------

macros += M o ===start_running
macros += M p ===run
macros += M \{9} ===tab
macros += M 5 ===wait

{
local POPCORN = 2 ^ 0
local EASY = 2 ^ 1
local MEDIUM = 2 ^ 2
local HARD = 2 ^ 3
local NIGHTMARE = 2 ^ 4
local IMPOSSIBLE = 2 ^ 5

local ESCAPE_KEY = string.char(27)
local BACKSPACE_KEY = string.char(8)
local TAB_KEY = string.char(9)
local ENTER_KEY = string.char(13)

local running = false
local attempt_turns = {}

function attempt(keys, index)
  -- always returns true when first called
  -- returns false if called more than once in the same turn

  index = index or "default"
  if you.turns() == attempt_turns[index] then return false end
  attempt_turns[index] = you.turns()
  crawl.sendkeys(keys)
  return true
end

function start_running()
  running = true
end

function stop_running(reason)
  if running then
    running = false
    print("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~")
  end

  if reason then print(reason) end
end

---------------------------------------------------------------------------
-- init                                                                  --
---------------------------------------------------------------------------

function init()
  c_persist.cleared_depth = {}
  c_persist.found = {}
  c_persist.flags = {}
  c_persist.monsters = {}
  c_persist.invisible_monster = nil
  c_persist.invisible_waypoint_exists = false
  c_persist.dancing = nil
  c_persist.where = you.where()
  train()
end

function train()
    you.train_skill("Axes", 2)
    you.train_skill("Armour", 1)
    you.train_skill("Fighting", 1)
    you.train_skill("Dodging", 1)
end

---------------------------------------------------------------------------
-- ready                                                                 --
---------------------------------------------------------------------------

function ready()
  crawl.redraw_screen()
  crawl.enable_more(false)
  crawl.more_autoclear(true)
  if you.turns() == 0 then init() end

  if c_persist.flags.exclude then
    c_persist.flags.exclude = false
    clear_exclusions()
  end

  -- todo: this does not work in pan

  if c_persist.where ~= you.where() then reset() end
  c_persist.where = you.where()
  persist_monsters()
  print_information()

  if is_scared() and hp_percent() <= 50 then stop_running() end
  if running then run() end
end

function print_information()
  local threat_level = adjusted_threat()
  local channel = nil
  local message = "Danger: " .. math.floor(danger_percent()) .. "% (" .. danger_text(threat_level) .. ")"
  if threat_level >= IMPOSSIBLE then channel = 6 end
  print(message, channel)
  print_extra_hard_monsters()
end

function reset()
  c_persist.monsters = {}
  c_persist.invisible_monster = nil
  c_persist.invisible_waypoint_exists = false
  stop_walking_away()
  stop_escaping()
end

function run()
  if can_walk_away() then
    start_walking_away()
  else
    stop_walking_away()
  end

  if is_walking_away() then
    if escape_bug() then
      stop_running("Escape bug (monster on stairs)!")
      return
    end

    if attempt_escape() then return end
	stop_walking_away()
    stop_running("Failed to walk away!")
  end

  if is_escaping() or can_stair_dance() then
    if escape_bug() then
      stop_running("Escape bug (monster on stairs)!")
      return
    end

    if attempt_escape() then return end
	stop_escaping()
    stop_running("Failed to escape!")
  end

  if is_safe() then
    explore()
    return
  end

  if not is_monster_present() then

    -- helps with clouds

    if attempt_mini_explore() then return end
    stop_running()
    return
  end

  if adjusted_threat() >= NIGHTMARE then
    -- if activate_ultra_instinct() then return end
    -- stop_running()
    -- return
  end

  fight()
end

function fight()
  if must_hand() then
    crawl.sendkeys("ab")
    return
  end

  if must_berserk() then
    crawl.sendkeys("aa")
    return
  end

  tab(true)
end

function activate_ultra_instinct()
  print("<cyan>ACTIVATE ULTRA INSTINCT!!</cyan>")

  if count_monsters() == 1 then
    fight()
    return true
  end

  if not you.slowed() and not you.berserk() then
    -- need to check if escaping is a good idea
    -- start_escaping()
    -- return true
  end

  print("ultra instinct failed", 6)
  return true

  -- fight()
  -- return true
end

---------------------------------------------------------------------------
-- exploration                                                           --
---------------------------------------------------------------------------

function is_caster()
  return not is_empty(you.spells())
end

function is_tired()
  return you.status("berserk cooldown") or
      hp_percent() < 100 or
      mp_percent() < 100 or
      you.slowed() or
      you.silencing() or
      you.confused() or
      you.status("barbed spikes") or
      you.status("marked") or
      you.corrosion() > 0 or
      has_bad_transformation()
end

function explore()
  if you.berserk() or is_tired() then
    if attempt("5") then return end

    -- we are stuck

    stop_running()
    return
  end

  if remove_curse() then return end
  if identify_items() then return end
  if upgrade_equipment() then return end
  if remove_dangerous_rings() then return end
  if drop_junk() then return end

  if is_shafted() then
    if attempt_mini_escape() or attempt("o") then return end

    -- we are stuck

    stop_running()
    return
  end

  if attempt("o") or attempt_goal() then return end

  -- we are stuck

  stop_running()
end

function is_feature_at(pattern, x, y)
  local feature = view.feature_at(x, y)
  return feature and feature:find(pattern)
end

function is_up_stairs(x, y)
  local feature = view.feature_at(x, y)
  return feature and (feature:find("stone_stairs_up") or feature:find("escape_hatch_up") or feature:find("exit"))
end

function is_down_stairs(x, y)
  local feature = view.feature_at(x, y)
  return feature and feature:find("stairs_down")
end

function cleared_depth(branch)
  branch = branch or you.branch()
  return c_persist.cleared_depth[branch] or 0
end

function is_shafted()
  return you.depth() > cleared_depth() + 1
end

function is_depth_cleared()
  return you.depth() <= cleared_depth()
end

function attempt_goal()
  return attempt("G" .. goal() .. ENTER_KEY .. ENTER_KEY, "attempt_goal")
end

function goal()
  if c_persist.found["Temple"] and c_persist.cleared_depth["Temple"] ~= 1 then
    return "T"
  end

  if c_persist.found["Lair"] then
    if c_persist.cleared_depth["Lair"] ~= 6 then
      return "L" .. cleared_depth("Lair") + 1
    end

    if c_persist.found["Orc"] and c_persist.cleared_depth["Orc"] ~= 2 then
      return "O" .. cleared_depth("Orc") + 1
    end
  end

  if c_persist.cleared_depth["D"] ~= 15 then
      return "D" .. cleared_depth("D") + 1
  end

  return ""
end

---------------------------------------------------------------------------
-- combat                                                                --
---------------------------------------------------------------------------

function panic()

  -- todo: conditionally use hand, bia, ambrosia, healing, curing

  if not you.teleporting() and teleport() then return true end
  return false
end

function teleport()
  for item in inventory() do
    if item.class(true) == "scroll" and item.subtype() == "teleportation" then
      return read_scroll(items.index_to_letter(item.slot))
    end
  end

  return false
end

function can_read()
  if you.status():find("cannot breathe") then return false end
  return not you.silenced() and not you.confused() and not you.berserk()
end

function monsters(radius)
  local result = {}

  for _, a in ipairs(points(radius)) do
    local b = monster.get_monster_at(a.x, a.y)
    if b and not b:is_safe() then util.append(result, {b}) end
  end

  return result
end

function has_bad_transformation()
  if you.transform() == "" then return false end
  return true
end

function tab(is_reckless)
  if hp_percent() <= 50 and not is_reckless then
    print("You are too injured to fight recklessly!")
    return
  end

  if is_dangerous_cloud(0, 0) then
    if attempt_approach(closest_adjacent_traversable(target:pos())) then return end

    -- we are stuck

    stop_running()
    return
  end

  if is_invisible_monster_present() then

    -- attacks adjacent invisible monsters with known locations

    if invisible_monster_location(1) then
      crawl.sendkeys("*" .. to_key(invisible_monster_location(1)))
      return
    end

    if not is_visible_monster_present() then

      -- if there are no visible monsters, attacks the last known location of an invisible monster

      local x, y = invisible_monster_location(nil, true)

      if x and y and is_traversable(clamp(x, -1, 1), clamp(y, -1, 1)) then
        crawl.sendkeys(to_key(clamp(x, -1, 1), clamp(y, -1, 1)))
        return
      end

      -- no invisible monster has a last known location

      if you.confused() then 
        if swing_at_nothing() then return end

        -- we are stuck

        stop_running()
        return
      end

      if attempt_unstuck() then return end

      -- we are stuck

      stop_running()
      return
    end

    -- a visible monster is present, so we fall through

  end

  -- attacks while confused

  if you.confused() then
    if hit_closest_monster() then return end

    -- we are stuck

    stop_running()
    return
  end

  crawl.sendkeys(TAB_KEY)
end

function swing_at_nothing()
  local point = first(where(adjacent(), function(point) return not is_sold(point.x, point.y) end))
  return point and attempt("*" .. to_key(point.x, point.y), "swing_at_nothing")
end

function wait()
  if is_tired() or
      you.berserk() or
      crawl.yesno("Are you sure you want to wait?", true, "n") then
    crawl.sendkeys("5")
  end
end

function must_berserk()
  -- todo: add better checks for if this ability is possible
  if is_safe() or not can_berserk() then
    return false
  end
  return is_angry()
end

function must_hand()
  -- todo: add better checks for if this ability is possible
  if is_safe() or
    you.piety_rank() < 2 or
    you.regenerating() or
    you.berserk() then
    return false
  end
  if find_monster("Sigmund") or find_monster("Grinder") then
    return true
  end
  return false
end

function can_walk_away()
  if can_see_up_stairs() and not can_stair_dance() then return false end

  if count_monsters() < 1 then return is_walking_away() end

  -- this is just a starting point, and needs to be improved

  if you.absdepth() == 1 and not you.have_orb() then return false end

  if is_depth_cleared() then return false end

  -- todo: in some cases you can walk away under these conditions

  if you.slowed() and count_monsters(1) > 0 then return false end
  if you.berserk() or util.exists(monsters(1), is_fast_monster) then return false end

  if count_monsters(nil, function(monster) return monster:has_known_ranged_attack() end) > 0 then return false end
  -- if length(where(monsters(), function(monster) return monster:has_known_ranged_attack() end)) > 0 then return false end
  return prevent_infinite_dancing()
end

function can_stair_dance()
  if you.absdepth() == 1 and not you.have_orb() or not can_see_up_stairs() then return false end

  -- todo: this does not work on ascension

  if is_depth_cleared() then return false end

  -- prevents stair dancing certain monsters

  if find_monster("Sigmund") then return false end

  -- prevents stair dancing loops caused by monsters with reach (might not be needed?)

  -- local can_reach = function(monster)
  --   local dist = distance(monster:pos())
  --   return dist > 0 and dist <= monster:reach_range()
  -- end

  -- if util.forall(monsters(), can_reach) then return false end

  -- prevents stair dancing if only undead monsters are adjacent

  local can_not_use_stairs = function(monster)
    return not can_use_stairs(monster)
  end

  if count_monsters(1, can_use_stairs) == 0 and count_monsters(1, can_not_use_stairs) > 0 then return false end
  return count_monsters() > count_monsters(1) and prevent_infinite_dancing()
end

function prevent_infinite_dancing(limit)
  local monster = closest_monster()
  local previous = c_persist.dancing
  local current = {name = monster:name(), count = 1}

  if previous and previous.name == current.name then
    previous.count = previous.count + 1
    if previous.count >= (limit or 100) then return false end
  else
    c_persist.dancing = current
  end

  return true
end

function escape_bug()
  local stairs = where(adjacent(), function(point) return is_down_stairs(point.x, point.y) end)
  return util.exists(stairs, function(point) return monster.get_monster_at(point.x, point.y) end)
end

function can_use_stairs(monster)
  return not monster:desc(true):find("incapable of using stairs")
end

function can_see_up_stairs(radius)
  local predicate = function(point)
    return is_up_stairs(point.x, point.y) and you.see_cell_no_trans(point.x, point.y)
  end

  return length(where(points(radius), predicate)) > 0
end

function is_fast_monster(monster)
  return monster:speed_description():find("fast") or monster:desc(true):find("quickly%.")
end

function is_monster(monster, pattern)
  return monster:name():find(pattern)
end

function is_monster_any(monster, patterns)
  return util.exists(patterns, function(pattern) return is_monster(monster, pattern) end)
end

function find_monster(pattern, radius)
  return first(where(monsters(radius), function(monster) return is_monster(monster, pattern) end))
end

function invisible_monster_location(radius, guess)
  local point = first(invisible_monsters(radius))

  if point then
    c_persist.invisible_waypoint_exists = true
    travel.set_waypoint(0, point.x, point.y)
    return point.x, point.y
  end

  if guess and c_persist.invisible_waypoint_exists then
    local x, y = travel.waypoint_delta(0)

    if x == 0 and y == 0 then
      c_persist.invisible_waypoint_exists = false
      return nil
    end

    if radius and distance(x, y) > radius then return nil end
    return -x, -y
  end
end

function count_monsters(radius, f)
  if f then return length(where(monsters(radius), f)) end
  return length(monsters(radius))
end

function is_angry()
  local adjacent = adjusted_threat(1)
  local total = adjusted_threat()

  -- berserk is used at 75% health against monsters with yellow names

  return adjacent >= MEDIUM and total >= MEDIUM * 4 / 3
end

function can_berserk()
  return you.god() == "Trog" and
      you.piety_rank() > 0 and
      not you.berserk() and
      not you.status("berserk cooldown") and
      not you.confused() and
      not you.silenced() and
      not you.mesmerised() and
      not you.status("afraid") and
      not you.caught()
end

function is_scared()
  if you.poison_survival() < 1 then return true end
  if is_safe() then return you.status("barbed spikes") or has_bad_transformation() end
  return adjusted_threat() >= NIGHTMARE -- IMPOSSIBLE
end

function has_spell(monster, name)
  local is_matching_spell = function(spell)
    return spell:find(name)
  end

  local is_matching_book = function(book)
    return util.exists(book, is_matching_spell)
  end

  return util.exists(monster:spells(), is_matching_book)
end

function has_electrocution_weapon(monster)
  return monster:desc(true):find("of electrocution%.")
end

function has_chaos_weapon(monster)
  return monster:desc(true):find("of chaos%.")
end

function has_distortion_weapon(monster)
  return monster:desc(true):find("of distortion%.")
end

function threat(radius)
  local result = sum(map(monsters(radius), calculate_threat))
  if not radius then return result + invisible_threat() end
  return result + invisible_threat(radius)
end

function adjusted_threat(radius)
  local multiplier = 1
  if you.slowed() then multiplier = multiplier + 1 end
  if you.confused() then multiplier = multiplier + 1 end
  if you.poisoned() then multiplier = multiplier + 1 end
  if you.corrosion() > 0 then multiplier = multiplier + 1 end
  return threat(radius) * multiplier * 100 / hp_percent()
end

function danger_percent()
  return math.min(adjusted_threat() * 100 / IMPOSSIBLE, 999)
end

function danger_text(value)
  if value >= IMPOSSIBLE then return "impossible" end
  if value >= NIGHTMARE then return "nightmare" end
  if value >= HARD then return "hard" end
  if value >= MEDIUM then return "medium" end
  if value >= EASY then return "easy" end
  if value >= POPCORN then return "popcorn" end
  return "safe"
end

function is_extra_hard(target)
  return calculate_threat(target) > 2 ^ target:threat()
end

function print_extra_hard_monsters(radius)
  local f = function(monster)
    print(monster:name() .. " (" .. danger_text(calculate_threat(monster)) .. ")", 6)
  end

  util.foreach(where(monsters(radius), is_extra_hard), f)
end

function calculate_threat(target)
  local hard = {"Natasha", "Eustachio"}

  -- early game

  util.append(hard, {"worm", "gnoll"})

  -- mid game

  util.append(hard, {"dream sheep", "hydra", "manticore"})

  -- late game

  util.append(hard, {"ugly thing", "boggart", "lurking horror"})

  -- giants

  util.append(hard, {"ogre", "cyclops", "ettin", "titan", "juggernaut"})

  -- resistances

  if not (you.res_poison() > 0) then
    util.append(hard, {"adder"})
  end

  if not (you.res_shock() > 0) then
    util.append(hard, {"sky beast", "electric eel", "shock serpent", "spark wasp", "electric golem"})
  end

  if not you.res_corr() then
    util.append(hard, {"jelly", "oklob"})
  end

  local result = target:threat()

  for _, name in ipairs(hard) do
    if target:name():find(name) then
      result = result + 1
    end
  end

  -- spells and abilities

  if target:is("berserk") or
      has_spell(target, "Smiting") or
      has_spell(target, "Banishment") or
      has_spell(target, "Petrify") or
      has_spell(target, "Petrifying Cloud") or
      has_spell(target, "Paralyse") or
      has_spell(target, "Paralysis Gaze") or
      has_spell(target, "Hurl Damnation") or
      has_spell(target, "Call Down Damnation") or
      has_spell(target, "Symbol of Torment") or
      has_spell(target, "Agony Range") or
      has_spell(target, "Flay") then
    result = result + 1
  end

  -- weapons

  if has_electrocution_weapon(target) or has_chaos_weapon(target) or has_distortion_weapon(target) then
    result = math.max(result, 3)
  end

  return 2 ^ result
end

function invisible_threat(radius)
  if not is_invisible_monster_present() then return 0 end
  local x, y = invisible_monster_location(radius, true)
  if radius and not x and not y then return 0 end
  local monster = c_persist.monsters[c_persist.invisible_monster]
  if monster then return monster.threat end

  -- should be HARD, only NIGHTMARE for debugging

  return NIGHTMARE
end

function is_visible_monster_present(radius)
  return not is_empty(monsters(radius))
end

function is_monster_present()
  return is_visible_monster_present() or is_invisible_monster_present()
end

function is_safe()
  return you.feel_safe() and not is_monster_present()
end

function hp_percent()
  local a, b = you.hp()
  return 100 * (you.poison_survival() or a) / b
end

function mp_percent()
  local a, b = you.mp()
  return 100 * a / b
end

function closest_monster(radius)
  local less_than = function(left, right)
    local left_distance = distance(left:pos())
    local right_distance = distance(right:pos())

    if left_distance == right_distance then
      return calculate_threat(left) < calculate_threat(right)
    end

    return left_distance < right_distance
  end

  local t = monsters(radius)
  table.sort(t, less_than)
  return first(t)
end

function hit_closest_monster()
  local target = closest_monster()
  if not target then return false end
  if distance(target:pos()) == 1 then return attempt("*" .. to_key(target:pos()), "hit_closest_monster") end
  return attempt_approach(target:pos())
end

function attempt_approach(x, y)
  local point = first(where(adjacent(), function(point) return is_closer_traversable(point.x, point.y, x, y) end))
  return point and attempt(to_key(point.x, point.y), "attempt_approach")
end

function is_closer_traversable(x0, y0, x1, y1)
  return is_traversable(x0, y0) and distance(x0, y0, x1, y1) < distance(x1, y1)
end

function is_traversable(x, y)
  return travel.feature_traversable(view.feature_at(x, y)) and
      not is_dangerous_cloud(x, y) and
      not monster.get_monster_at(x, y)
end

function is_sold(x, y)
  return travel.feature_solid(view.feature_at(x, y))
end

function invisible_monsters(radius)
  return where(points(radius), function(point) return view.invisible_monster(point.x, point.y) end)
end

function is_invisible_monster_present()
  return not options.autopick_on or not is_empty(invisible_monsters())
end

function closest_adjacent_traversable(x, y)
  local adjacent = {}
  for a = -1, 1 do
    for b = -1, 1 do
      if not (a == 0 and b == 0) and is_traversable(a, b) then
        local cell = point(a, b)
        adjacent[length(adjacent) + 1] = cell
      end
    end
  end
  if length(adjacent) > 0 then
    table.sort(adjacent, function(p0, p1)
      return distance(p0.x, p0.y, x, y) < distance(p1.x, p1.y, x, y)
    end)
    return adjacent[1].x, adjacent[1].y
  end
end

function adjacent()
  return where(points(1), function(point) return point.x ~= 0 or point.y ~= 0 end)
end

---------------------------------------------------------------------------
-- complex combat                                                        --
---------------------------------------------------------------------------

-- todo

---------------------------------------------------------------------------
-- fast travel                                                           --
---------------------------------------------------------------------------

function attempt_unstuck()
  return attempt_mini_escape() or attempt_mini_explore() or attempt_mini_dive()
end

function attempt_mini_escape()
  if you.confused() then return false end
  if view.feature_at(0, 0) == "exit_dungeon" and not you.have_orb() then return false end
  if is_up_stairs(0, 0) then return attempt("<", "attempt_mini_escape") end
  return attempt("X<." .. ESCAPE_KEY, "attempt_mini_escape")
end

function attempt_mini_explore()
  if you.confused() then return false end
  return attempt("Xo." .. ESCAPE_KEY, "attempt_mini_explore")
end

function attempt_mini_dive()
  if you.confused() then return false end
  if is_down_stairs(0, 0) then return attempt(">", "attempt_mini_dive") end
  return attempt("X>." .. ESCAPE_KEY, "attempt_mini_dive")
end

---------------------------------------------------------------------------
-- escaping                                                              --
---------------------------------------------------------------------------

function is_escaping()
  return c_persist.flags.escaping or false
end

function start_escaping()
  c_persist.flags.escaping = true
end

function stop_escaping()
  c_persist.flags.escaping = false
end

function is_walking_away()
  return c_persist.flags.walking_away or false
end

function start_walking_away()
  c_persist.flags.walking_away = true
end

function stop_walking_away()
  c_persist.flags.walking_away = false
end

function attempt_escape()
  if you.absdepth() == 1 and not you.have_orb() then return false end
  if is_up_stairs(0, 0) then return attempt("<", "attempt_escape") end
  local stairs = where(adjacent(), function(point) return is_up_stairs(point.x, point.y) end)

  if length(stairs) > 0 then
    local traversable_stairs = where(stairs, function(point) return is_traversable(point.x, point.y) end)
    local point = first(traversable_stairs)
    if not point then return false end
    return attempt(to_key(point.x, point.y), "attempt_escape")
  end

  c_persist.flags.exclude = true
  return attempt("X<." .. ESCAPE_KEY, "attempt_escape")
end

function exclude_monsters(radius)
  util.foreach(monsters(), function(monster) travel.set_exclude(monster:x_pos(), monster:y_pos(), radius or 0) end)
end

function exclude_runed_doors(radius)
  local points = where(points(), function(point) return is_feature_at("runed_clear_door", point.x, point.y) end)
  util.foreach(points, function(point) travel.set_exclude(point.x, point.y, radius or 0) end)
end

function clear_exclusions()
  crawl.sendkeys("X" .. control("e") .. ESCAPE_KEY)
end

---------------------------------------------------------------------------
-- item dropping                                                         --
---------------------------------------------------------------------------

function drop(item)
  local letter = items.index_to_letter(item.slot)
  crawl.sendkeys("d" .. letter .. ENTER_KEY)
end

function can_drop_if_burdened(item)
  if item.class(true) == "wand" and
      item.subtype() ~= "digging" then
    for other in inventory() do
      -- keep if there is a worse wand that can be dropped instead
      if other.class(true) == "wand" and wand_level(other) < wand_level(item) then
        return false
      end
    end
    return true
  end
  return false
end

function drop_junk()
  for item in inventory() do
    if is_junk(item) then
      if not (item.cursed and item.equipped) then
        drop(item)
        return true
      end
    end
  end
  return false
end

function is_junk_weapon(item)
  if item.class(true) == "weapon" then
    if not uses_weapon_skill(item) or god_hates(item) then
      return true
    end
    for other in inventory() do
      if not god_hates(other) and compare_weapons(item, other) < 0 then
        return true
      end
    end
  end
  return false
end

function god_hates(item)
  if you.god() == "Trog" and item:ego() == "pain" then
    return true
  end
  return false
end

function is_junk_armour(item)
  if is_scales(item) then
    return false
  end
  if item:ego() == "harm" then
    return true
  end
  if item.class(true) == "armour" then
    for other in inventory() do
      if compare_armour(item, other) < 0 then
        return true
      end
    end
  end
  return false
end

function is_junk_ring(item)
  if is_ring(item) then
    if item.subtype() == "ring of teleportation" or
        item.subtype() == "ring of attention" then
      return true
    end
    if item.plus and item.plus < 0 then
      return true
    end
  end
  return false
end

function is_dangerous_item(item)
  if is_ring(item) then return item.subtype() == "ring of fire" or item.subtype() == "ring of ice" end
  if is_scales(item) then return item:name():find("fire dragon scales") or item:name():find("ice dragon scales") end
  return false
end

function is_junk(item)
  if item.artefact then
    return false
  end
  if is_junk_weapon(item) or
      is_junk_armour(item) or
      is_junk_amulet(item) or
      is_junk_ring(item) or
      is_unneeded_duplicate(item) then
    return true
  end
  if burdened() and can_drop_if_burdened(item) then
    return true
  end
  local junk_subtypes = {
    --"brilliance",
    --"holy word",
    --"silence",
    "attraction",
    "degeneration",
    "lignification",
    "immolation",
    "noise",
    "random uselessness",
    "torment",
    "vulnerability"}
  for _, subtype in ipairs(junk_subtypes) do
    if item.subtype() == subtype then 
      return true
    end
  end
  return false
end

---------------------------------------------------------------------------
-- autopickup                                                            --
---------------------------------------------------------------------------

function is_unneeded_duplicate(item)
  if item.artefact or
      item.equipped or
      item.class(true) == "missile" or
      item.class(true) == "potion" or
      item.class(true) == "scroll" then
    return false
  end
  for other in inventory() do
    if item.slot ~= other.slot and
        other:name() == item:name() and
        item:ego() == other:ego() and
        (item.plus or 0) == (other.plus or 0) then
      return true
    end
  end
  return false
end

function want_weapon(item)
  if item.subtype() == "hand axe" and not item.fully_identified then
    -- avoids early cursed hand axes
    return false
  end
  if item.class(true) == "weapon" then
    local best = best_damage(item.weap_skill)
    if item.damage > best then
      return true
    end
    if item.damage == best then
      return item.branded
    end
  end
  return false
end

function want_armour(item)
  if is_scales(item) then
    return true
  end

  -- todo: this currently ignores branded robes

  if item.class(true) == "armour" then
    local best = best_ac(item.subtype())
    if item.ac > best then
      return true
    end

    if item.subtype() == "helmet" or
        item.subtype() == "cloak" or
        item.subtype() == "gloves" or
        item.subtype() == "boots" then
      return item.branded
    end
  end

  return false
end

function best_armour_to_enchant()
  -- todo: handle shields
  -- todo: handle body armours
  local boots = items.equipped_at("Boots")
  if boots and (boots.plus or 0) < 2 and not boots.artefact then
    return boots
  end
  local gloves = items.equipped_at("Gloves")
  if gloves and (gloves.plus or 0) < 2 and not gloves.artefact then
    return gloves
  end
  local helmet = items.equipped_at("Helmet")
  if helmet and (helmet.plus or 0) < 2 and not helmet.artefact then
    return helmet
  end
  local cloak = items.equipped_at("Cloak")
  if cloak and cloak.ac > 0
      and (cloak.plus or 0) < 2 and
      not cloak.artefact then
    return cloak
  end
  local body = items.equipped_at("Armour")
  if body and (body.plus or 0) < 2 and not body.artefact then
    return body
  end
  -- local shield = items.equipped_at("Shield")
end

function want_book(item)
  return item.class(true) == "book" and not item.is_useless
end

function autopickup(item, name)
  if is_unneeded_duplicate(item) or
      is_slot_missing(item) or
      is_junk(item) then
    return false
  end
  if item.artefact then
    return true
  end
  if want_book(item) then
    return true
  end
  if want_weapon(item) then
    return true
  end
  if want_armour(item) then
    return true
  end
end

add_autopickup_func(autopickup)

---------------------------------------------------------------------------
-- curse removal                                                         --
---------------------------------------------------------------------------

function scroll_of_remove_curse_letter()
  for item in inventory() do
    if item.class(true) == "scroll" and
        item.subtype() == "remove curse" then
      return items.index_to_letter(item.slot)
    end
  end
end

function remove_curse()
  local rc_letter = scroll_of_remove_curse_letter()
  if rc_letter then
    for item in inventory() do
      if item.cursed and item.equipped then
        return read_scroll(rc_letter)
      end
    end
  end
  return false
end

---------------------------------------------------------------------------
-- item identification                                                   --
---------------------------------------------------------------------------

function scroll_of_identify_letter()
  for item in inventory() do
    if item.class(true) == "scroll" and item.subtype() == "identify" then
      return items.index_to_letter(item.slot)
    end
  end
end

function scroll_of_blinking_letter()
  for item in inventory() do
    if item.class(true) == "scroll" and item.subtype() == "blinking" then
      return items.index_to_letter(item.slot)
    end
  end
end

function want_to_identify_with_scroll(item)
  if not item.fully_identified and not item.artefact then
    if is_faith_equipped() and is_amulet(item) then
      return true
    end
    if item.class(true) == "potion" then
      return true
    end
    if item.class(true) == "scroll" and
        scroll_of_identify_quantity() > 5 then
      return true
    end
  end
  return false
end

function want_to_use_scroll_of_identify()
  for item in inventory() do
    if want_to_identify_with_scroll(item) then
      return true
    end
  end
  return false
end

function scroll_of_identify_quantity()
  for item in inventory() do
    if item.class(true) == "scroll" and item.subtype() == "identify" then
      return item.quantity
    end
  end
  return 0
end

function identify_items()
  local id_letter = scroll_of_identify_letter() 
  for item in inventory() do
    if item.class(true) == "scroll" and
        not item.fully_identified and
        item.quantity > 1 and
        (c_persist.found.scroll_of_identify or want_to_use_scroll_of_identify()) then
      return read_scroll(items.index_to_letter(item.slot))
    end
  end
  if id_letter then
    for item in inventory() do
      if want_to_identify_with_scroll(item) then
        return read_scroll(id_letter .. items.index_to_letter(item.slot))
      end
    end
  end
  return false
end

---------------------------------------------------------------------------
-- item utility                                                          --
---------------------------------------------------------------------------

function inventory()
  return iter.invent_iterator:new(items.inventory())
end

function burdened()
  return length(items.inventory()) > 47
end

function read_scroll(letter)
  if can_read() then
    crawl.sendkeys("r" .. letter)
    return true
  end

  return false
end

---------------------------------------------------------------------------
-- equipment utility                                                     --
---------------------------------------------------------------------------

function uses_weapon_skill(item)
  return item.class(true) == "weapon" and item.weap_skill == "Axes"
end

function is_scales(item)
  return item.name():find("scales")
end

function wand_level(wand)
  if wand.subtype() == "digging" then
    return 9
  end
  if wand.subtype() == "acid" then
    return 8
  end
  if wand.subtype() == "iceblast" then
    return 7
  end
  if wand.subtype() == "paralysis" then
    return 6
  end
  if wand.subtype() == "enslavement" then
    return 5
  end
  if wand.subtype() == "disintegration" then
    return 4
  end
  if wand.subtype() == "flame" then
    return 3
  end
  if wand.subtype() == "polymorph" then
    return 2
  end
  if wand.subtype() == "random effects" then
    return 1
  end
  return 0
end

function cloak_level(item)
  if item:ego() == "resistance" then
    return 5
  end

  if item:ego() == "poison resistance" then
    return 4
  end

  if item:ego() == "preservation" then
    return 4
  end

  if item:ego() == "fire resistance" then
    return 4
  end

  if item:ego() == "cold resistance" then
    return 4
  end

  if item:ego() == "repulsion" then
    return 3
  end

  if item:ego() == "willpower" then
    return 2
  end

  if item:ego() == "stealth" then
    return 1
  end

  -- don't care about invisibility

  if item:ego() == "invisibility" then
    return 0
  end

  -- harm is junk

  if item:ego() == "harm" then
    return -1
  end

  -- don't care about other brands

  return 0
end

function boots_level(item)
  if item:ego() == "running" then
    return 3
  end

  if item:ego() == "flying" then
    return 2
  end

  if item:ego() == "stealth" then
    return 1
  end

  -- don't care about other brands

  return 0
end

function gloves_level(item)
  if item:ego() == "strength" then
    return 2
  end

  if item:ego() == "dexterity" then
    return 1
  end

  -- don't care about archery

  if item:ego() == "archery" then
    return 0
  end

  -- don't care about other brands

  return 0
end

function body_level(item)
  if item:name():find("gold dragon scales") then
    return 1
  end

  if item:name():find("storm dragon scales") then
    return 1
  end

  if item:name():find("shadow dragon scales") then
    return 1
  end

  if item:name():find("pearl dragon scales") then
    return 1
  end

  -- fire and ice scales are dangerous

  if item:name():find("fire dragon scales") then
    return -1
  end

  if item:name():find("ice dragon scales") then
    return -1
  end

  -- don't care about other types

  return 0
end

function equip_ring(item, letter)
  if item.equipped or not is_ring(item) then return false end

  if is_ring_missing() then
    crawl.sendkeys("P" .. items.index_to_letter(item.slot))
    return true
  end

  local left = items.equipped_at("Left Ring")
  local right = items.equipped_at("Right Ring")
  if left.cursed and right.cursed then return false end

  if left.cursed or right.cursed or left.subtype() == right.subtype() and left.plus == right.plus then
    crawl.sendkeys("P" .. items.index_to_letter(item.slot))
    return true
  end

  if compare_rings(left, right) > 0 then
    letter = letter or ">"
  else
    letter = letter or "<"
  end

  crawl.sendkeys("P" .. items.index_to_letter(item.slot) .. letter)
  return true
end

function is_ring_missing()
  return not items.equipped_at("Left Ring") or not items.equipped_at("Right Ring")
end

function equipped_at(subtype)
  local translations = {
    cloak = "Cloak",
    helmet = "Helmet",
    gloves = "Gloves",
    boots = "Boots",
    body = "Armour",
    shield = "Shield"}
  return items.equipped_at(translations[subtype])
end

function is_slot_missing(item)
  if item.class(true) == "armour" then
    return item.subtype() == "shield" or item.name():find("barding")
  end
  return false
end

function upgrade_equipment()
  for item in inventory() do
    if not item.equipped and
        not item.artefact and
        not is_dangerous_item(item) and
        not is_slot_missing(item) and
        not is_junk(item) then
      if item.class(true) == "weapon" then
        local equipped = items.equipped_at("Weapon")
        if not equipped or
            not item.fully_identified or
            compare_weapons(item, equipped) > 0 then
          if not (equipped and equipped.cursed) and
              item.wield() then
            return true
          end
        end
      end
      if item.class(true) == "armour" then
        local equipped = equipped_at(item.subtype())
        if not equipped or
            not item.fully_identified or
            compare_armour(item, equipped) > 0 then
          if not (equipped and equipped.cursed) and
              item.wear() then
            return true
          end
        end
      end
      if is_amulet(item) then
        local equipped = items.equipped_at("Amulet")
        if not equipped or
            not item.fully_identified and not is_faith_equipped() or
            compare_amulets(item, equipped) > 0 then
          if not (equipped and equipped.cursed)
              and not is_faith_bound() then
            crawl.sendkeys("P" .. items.index_to_letter(item.slot))
            return true
          end
        end
      end
      -- rings are not fully supported yet
      if is_ring(item) then
        if is_ring_missing() or
            not item.fully_identified then
          if equip_ring(item) then
            return true
          end
        end
        local left = items.equipped_at("Left Ring")
        if not (left and left.cursed) and
            compare_rings(item, left) > 0 and
            equip_ring(item) then
          return true
        end
        local right = items.equipped_at("Right Ring")
        if not (right and right.cursed) and
            compare_rings(item, right) > 0 and
            equip_ring(item) then
          return true
        end
      end
    end
  end
  return false
end

---------------------------------------------------------------------------
-- weapon and armour utility                                             -- 
---------------------------------------------------------------------------

function compare_weapons(left, right)
  -- todo: handle artefacts
  if left.artefact or right.artefact then
    return 0
  end
  if left.is_useless or right.is_useless then
    return 0
  end
  if left.class(true) ~= "weapon" or right.class(true) ~= "weapon" then
    return 0
  end
  if left.weap_skill ~= right.weap_skill then
    return 0
  end
  if not left.fully_identified or not right.fully_identified then
    return 0
  end
  local result = compare(left.damage, right.damage)
  if result ~= 0 then return result end
  result = compare(weapon_brand_level(left:ego()), weapon_brand_level(right:ego()))
  if result ~= 0 then return result end
  return compare(left.plus or 0, right.plus or 0)
end

function weapon_brand_level(brand)
  local extended = false
  if brand == "holy wrath" then
    if extended then
      return 9
    end
    return 0
  end
  if brand == "vampirism" then
    if extended then
      return 0
    end
    return 9
  end
  if brand == "electrocution" then
    return 8
  end
  if brand == "flaming" then
    return 7
  end
  if brand == "freezing" then
    return 6
  end
  if brand == "draining" then
    return 5
  end
  if brand == "venom" then
    return 4
  end
  if brand == "vorpality" then
    return 3
  end
  if brand == "protection" then
    return 2
  end
  if brand == "antimagic" then
    return 1
  end
  if not brand then
    return 0
  end
  if brand == "chaos" then
    return -1
  end
  if brand == "distortion" then
    return -2
  end
  if brand == "pain" then
    return -3
  end
  -- unknown brands
  return -4
end

function compare_armour(left, right)
  -- todo: handle artefacts
  if left.artefact or right.artefact then
    return 0
  end

  if left.is_useless or right.is_useless then
    return 0
  end

  if not left.class(true) == "armour" or
      not right.class(true) == "armour" then
    return 0
  end

  if left.subtype() ~= right.subtype() then
    return 0
  end

  if not left.fully_identified or not right.fully_identified then
    return 0
  end

  result = 0

  if left.subtype() == "body" then
    result = compare(body_level(left), body_level(right))
  elseif left.subtype() == "helmet" then
    result = compare(helmet_level(left), helmet_level(right))
  elseif left.subtype() == "cloak" then
    result = compare(cloak_level(left), cloak_level(right))
  elseif left.subtype() == "gloves" then
    result = compare(boots_level(left), boots_level(right))
  elseif left.subtype() == "boots" then
    result = compare(gloves_level(left), gloves_level(right))
  end

  if result ~= 0 then
    return result
  end

  return compare(left.ac + (left.plus or 0), right.ac + (right.plus or 0))
end

function best_damage(weap_skill)
  local result = 0
  for item in inventory() do
    if item.weap_skill == weap_skill and item.damage > result then
      result = item.damage
    end
  end
  return result
end

function best_ac(subtype)
  local result = 0
  for item in inventory() do
    if item.subtype() == subtype and item.ac > result then
      result = item.ac
    end
  end
  return result
end

---------------------------------------------------------------------------
-- helmets                                                               --
---------------------------------------------------------------------------

function helmet_level(item)
  if item:ego() == "see invisible" then
    if species_has_mutation("see invisible") then return 0 end
    return 3
  end

  if item:ego() == "intelligence" then
    if not is_caster() then return 0 end
    return 2
  end

  if item:ego() == "willpower" then return 1 end

  -- don't care about other brands

  return 0
end

---------------------------------------------------------------------------
-- amulets                                                               --
---------------------------------------------------------------------------

function is_amulet(item)
  if item.class(true) ~= "jewellery" then return false end
  return item.name():find("amulet") or item.name():find("necklace")
end

function is_faith_equipped()
  local amulet = items.equipped_at("Amulet")
  return amulet and amulet.subtype() == "amulet of faith"
end

function is_faith_bound()
  return is_faith_equipped() and you.piety_rank() < 6
end

function compare_amulets(left, right)

  -- todo: handle artefacts

  if left.artefact or right.artefact then
    return 0
  end

  if not is_amulet(left) or not is_amulet(right) then return 0 end
  if not left.fully_identified or not right.fully_identified then return 0 end
  return compare(amulet_level(left), amulet_level(right))
end

function amulet_level(amulet)
  if amulet.subtype() == "amulet of regeneration" then return 6 end

  if amulet.subtype() == "amulet of guardian spirit" then
    if is_caster() then return 0 end
    return 5
  end

  if amulet.subtype() == "amulet of faith" then return 4 end
  if amulet.subtype() == "amulet of the acrobat" then return 3 end
  if amulet.subtype() == "amulet of reflection" then return 2 end
  if amulet.subtype() == "amulet of magic regeneration" then return 1 end
  return 0
end

function is_junk_amulet(item)
  if is_amulet(item) then
    if item.subtype() == "amulet of inaccuracy" then return true end
    if item.equipped and is_faith_bound() then return false end

    for other in inventory() do
      if compare_amulets(item, other) < 0 then return true end
    end
  end

  return false
end

---------------------------------------------------------------------------
-- rings                                                                 --
---------------------------------------------------------------------------

function is_ring(item)
  if item.class(true) ~= "jewellery" then return false end
  return item.name():find("ring")
end

function compare_rings(left, right)

  -- todo: handle artefacts

  if left.artefact or right.artefact then return 0 end
  if not is_ring(left) or not is_ring(right) then return 0 end
  if not left.fully_identified or not right.fully_identified then return 0 end
  return compare(ring_level(left), ring_level(right))
end

function ring_level(ring)

  -- todo: add better ring logic

  if ring.subtype() == "ring of see invisible" then
    return 0
  end

  if ring.subtype() == "ring of poison resistance" then
    return 0
  end

  if ring.subtype() == "ring of protection from fire" then
    return 0
  end

  if ring.subtype() == "ring of protection from cold" then
    return 0
  end

  if ring.subtype() == "ring of resist corrosion" then
    return 0
  end

  if ring.subtype() == "ring of positive energy" then
    return 0
  end

  if ring.subtype() == "ring of slaying" then
    return 7
  end

  if ring.subtype() == "ring of protection" then
    return 6
  end

  if ring.subtype() == "ring of evasion" then
    return 5
  end

  if ring.subtype() == "ring of willpower" then
    return 4
  end

  if ring.subtype() == "ring of stealth" then
    return 3
  end

  if ring.subtype() == "ring of strength" then
    return 2
  end

  if ring.subtype() == "ring of dexterity" then
    return 1
  end

  -- flight, magical power, wizardry, intelligence, fire, ice

  return 0
end

function remove_dangerous_rings()
  for item in inventory() do
    if item.equipped and not item.cursed and is_ring(item) and is_dangerous_item(item) then
      if item.remove() then return true end
    end
  end

  return false
end

---------------------------------------------------------------------------
-- functional utility                                                    --
---------------------------------------------------------------------------

function length(t)
  return table.getn(t)
end

function is_empty(t)
  return length(t) == 0
end

function first(t)
  return t[1]
end

function where(t, f)
  local result = {}

  for _, a in ipairs(t) do
    if f(a) then util.append(result, {a}) end
  end

  return result
end

function map(t, f)
  local result = {}

  for _, a in ipairs(t) do
    util.append(result, {f(a)})
  end

  return result
end

function join(t)
  -- replace this with util.join?

  local result = ""

  for key, value in ipairs(t) do
    result = result .. value
    if key < length(t) then result = result .. ", " end
  end

  return result
end

---------------------------------------------------------------------------
-- math utility                                                          --
---------------------------------------------------------------------------

function sum(t)
  local result = 0

  for _, a in ipairs(t) do
    result = result + a
  end

  return result
end

function distance(x0, y0, x1, y1)
  return math.max(math.abs(x0 - (x1 or 0)), math.abs(y0 - (y1 or 0)))
end

function cartesian_distance(x0, y0, x1, y1)
  return math.sqrt((x0 - (x1 or 0)) ^ 2 + (y0 - (y1 or 0)) ^ 2)
end


function compare(left, right)
  if left < right then return -1 end
  if left > right then return 1 end
  return 0
end

function clamp(value, min, max)
  if value < min then return min end
  if value > max then return max end
  return value
end

function point(a, b)
  return {x = a, y = b}
end

function points(radius)
  radius = radius or 8
  local result = {}

  for x = -radius, radius do
    for y = -radius, radius do
      util.append(result, {point(x, y)})
    end
  end

  return result
end

---------------------------------------------------------------------------
-- general utility                                                       --
---------------------------------------------------------------------------

function print(object, channel)
  if type(object) == "table" then
    crawl.mpr(encode(object), channel)
  else
    crawl.mpr(tostring(object), channel)
  end
end

function encode(object)
  if type(object) == "string" then return '"' .. object .. '"' end

  if type(object) == "table" then
    local table = {}

    for key, value in pairs(object) do
      util.append(table, {encode(key) .. ": " .. encode(value)})
    end

    return "{" .. join(table) .. "}"
  end

  return tostring(object)
end

function sanitize(string)
  string = string:gsub("<%w*>", "")
  string = string:gsub("</%w*>", "")
  string = string:gsub("[^%w]", "")
  return string:lower()
end

function monster_to_table(monster)
  return {name = monster:name(), x = monster:x_pos(), y = monster:y_pos(), threat = calculate_threat(monster)}
end

function to_key(x, y)
  local keys = {"b", "j", "n", "h", "s", "l", "y", "k", "u"}
  return keys[5 + x - 3 * y]
end

function control(letter)
  return string.char(string.byte(letter) - string.byte("a") + 1)
end

---------------------------------------------------------------------------
-- hooks                                                                 --
---------------------------------------------------------------------------

function c_answer_prompt(prompt)
  --if prompt:find("Really walk") then return true end
  if prompt:find("Keep equipping") then return true end
  if prompt:find("Keep disrobing") then return false end

  if prompt:find("Really unwield") or
      prompt:find("Really take off") or
      prompt:find("Really remove") or
      prompt:find("Really wield") or
      prompt:find("Really wear") or
      prompt:find("Really put on") then
    return true
  end
end

function c_message(text, channel)
  if channel == "error" then
    stop_running()
    return
  end

  if text:find("suddenly seem different") then
    reset()
    return
  end

  if text:find("to the Ecumenical Temple") then
    c_persist.found["Temple"] = true
    return
  end

  if text:find("to the Lair") then
    c_persist.found["Lair"] = true
    return
  end

  if text:find("to the Orc") then
    c_persist.found["Orc"] = true
    return
  end

  if text:find("explore") or text:find("exploring") then
    exclude_runed_doors()

    -- finished exploring

    if you.depth() == cleared_depth() + 1 then c_persist.cleared_depth[you.branch()] = you.depth() end
    return
  end

  if text:find("reachable target") or text:find("move towards target") then

    -- todo: add logic to handle unreachable electric eels

    if not attempt_mini_explore() then

      -- finished exploring

      if you.depth() == cleared_depth() + 1 then c_persist.cleared_depth[you.branch()] = you.depth() end
      start_escaping()
    end

    return
  end

  if text:find("There is an entrance") and view.feature_at(0, 0) == "enter_shop" then
    crawl.sendkeys(ESCAPE_KEY)
    return
  end

  -- item identification

  if text:find("is a scroll of identify") then
    c_persist.found.scroll_of_identify = true

    for item in inventory() do
      if want_to_identify_with_scroll(item) then
        crawl.sendkeys(items.index_to_letter(item.slot))
        return
      end
    end

    return
  end

  if text:find("is a scroll of enchant weapon") then
    local equipped = items.equipped_at("Weapon")

    if equipped and not equipped.artefact then
      if (equipped.plus or 0) < 9 then
        crawl.sendkeys(items.index_to_letter(equipped.slot))
        return
      end
    end

    return
  end

  if text:find("is a scroll of enchant armour") then
    local equipped = best_armour_to_enchant()

    if equipped then
      crawl.sendkeys(items.index_to_letter(equipped.slot))
    end

    return
  end

  if text:find("Blink to where?") then
    if not scroll_of_blinking_letter() then
      crawl.sendkeys("fy")
    end

    return
  end

  -- invisible monsters

  if text:find("the .* flickers and vanishes") then
    local _, _, match = text:find("the (.*) flickers and vanishes")
    c_persist.invisible_monster = sanitize(match)
    local monster = c_persist.monsters[c_persist.invisible_monster]
    travel.set_waypoint(0, monster.x, monster.y)
    c_persist.invisible_waypoint_exists = true
    return
  end

  if text:find(".* flickers and vanishes") then
    local _, _, match = text:find("(.*) flickers and vanishes")
    c_persist.invisible_monster = sanitize(match)
    local monster = c_persist.monsters[c_persist.invisible_monster]
    travel.set_waypoint(0, monster.x, monster.y)
    c_persist.invisible_waypoint_exists = true
    return
  end

  if text:find("the .* flickers out of sight") then
    local _, _, match = text:find("the (.*) flickers out of sight")
    c_persist.invisible_monster = sanitize(match)
    local monster = c_persist.monsters[c_persist.invisible_monster]
    travel.set_waypoint(0, monster.x, monster.y)
    c_persist.invisible_waypoint_exists = true
    return
  end

  if text:find("Reactivating autopickup") then
    c_persist.invisible_monster = nil
    c_persist.invisible_waypoint_exists = false
    return
  end
end

function ch_start_running(kind)
  if kind == "intertravel" and c_persist.flags.exclude then

    -- todo: this does not work when the monster is on stairs!

    exclude_monsters()
  end
end

function choose_stat_gain()
  return "i"
end

---------------------------------------------------------------------------
-- debug                                                                 --
---------------------------------------------------------------------------

function species_has_mutation(mutation)
  return you.get_base_mutation_level(mutation, true, false, false) > 0
end

function debug()
  print(c_persist.monsters[c_persist.invisible_monster])
end

function persist_monsters(radius)
  util.foreach(map(monsters(radius), monster_to_table), function(table) c_persist.monsters[sanitize(table.name)] = table end)
end

function is_dangerous_cloud(x, y)
  local cloud = view.cloud_at(x, y)

  if not cloud or
      view.is_safe_square(x, y) or

      -- safe clouds

      cloud:find("smoke") or
      cloud:find("energy") or
      cloud:find("salt") or
      cloud:find("rain") then
    return false
  end

  return true
end

}

macros += M c ===debug
macros += M 0 ===debug_escape