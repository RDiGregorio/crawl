# DCSS 0.26

# use the c_message hook instead of searching last message!
# handle oklob plant
# handle shops: items.shop_inventory() and items.shopping_list()
# script wand usage on eels, some blinkers
# script special tactics for certain monsters
# need to add checks for safe and automatically trigger it
# NEED TO SANITIZE MONSTER NAMES TO USE AS TABLE KEYS!!
# prevent running in some cases (berserk, slow, poisoned?)
# prevent running if some fast mobs are adjacent?

# escape logic needs a LOT of work
# can macro the escape key to get around paralysis force more
# scroll of identify is buggy when you have artifacts
# ring logic is buggy, trying to equip rings you are already wearing
# can walk into travel exclusions while tabbing

# add logic to bia when piety > 4
# improve logic for when you can't reach an electric eel
# run on torment
# add hallway preference, improve the can escape logic

-------------------------------------------------------------------------
-- options                                                             --
-------------------------------------------------------------------------

bindkey = [s] CMD_NO_CMD_DEFAULT
bindkey = [p] CMD_NO_CMD_DEFAULT

travel_delay = -1
travel_key_stop = false
show_travel_trail = false
rest_delay = -1
explore_auto_rest = true
rest_wait_both = true
show_more = false
easy_confirm = all
autofight_stop = 0
autofight_caught = true
travel_one_unsafe_move = true

explore_stop = stairs, shops, altars, portals, branches, runed_doors
explore_stop += greedy_pickup

#autopickup_exceptions += brilliance, holy word, silence
#autopickup_exceptions += polymorph, random effects

autopickup_exceptions += <phantom mirror, <throwing net

auto_exclude = oklob plant, Roxanne, orange crystal statue, diamond obelisk

channel.intrinsic_gain = mute
channel.god = mute
channel.multiturn = mute
channel.talk = mute
channel.talk_visual = mute
channel.timed_portal = mute
cannel.sound = mute
channel.monster_damage = mute

message_colour += mute:menu to convert
message_colour += mute:Move the cursor to view the level map
message_colour += mute:Returning to the game

use_animations -= beam, pickup, branch_entry
#use_animations -= range, hp, monster_in_sight, monster, player

species = ho
background = be
weapon = hand axe
default_manual_training = true

---------------------------------------------------------------------------
-- main                                                                  --
---------------------------------------------------------------------------

macros += M o ===start_running
macros += M p ===step
macros += M \{9} ===tab
macros += M 5 ===wait

{
local POPCORN = 2 ^ 0
local EASY = 2 ^ 1
local MEDIUM = 2 ^ 2
local HARD = 2 ^ 3
local NIGHTMARE = 2 ^ 4
local IMPOSSIBLE = 2 ^ 5

local ESCAPE_KEY = string.char(27)
local BACKSPACE_KEY = string.char(8)
local TAB_KEY = string.char(9)
local ENTER_KEY = string.char(13)

local running = false

local invisible_waypoint_exists = false
local invisible_monster_name = nil
local attempt_turns = {}

function attempt(keys, index)
  -- always returns true when first called
  -- returns false if called more than once in the same turn

  index = index or "default"
  local turns = attempt_turns[index] or -1

  if you.turns() == turns then
    return false
  end

  attempt_turns[index] = you.turns()
  crawl.sendkeys(keys)
  return true
end

function start_running()
  running = true
end

function stop_running()
  if running then
    running = false
    print("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~")
  end
end

function ready()
  crawl.enable_more(false)
  crawl.more_autoclear(true)

  if c_persist.flags and c_persist.flags["exclude"] then
    c_persist.flags["exclude"] = false
    clear_exclusions()
  end

  if housekeeping() then
    run()
  end
end

function housekeeping()
  if you.turns() == 0 then
    c_persist.cleared_depth = {}
    c_persist.found = {}
    c_persist.flags = {}
    c_persist.dancing = nil
    c_persist.where = you.where()
    train()
  end

  -- todo: this does not work in pan

  if c_persist.where ~= you.where() then
    invisible_monster_name = nil
    invisible_waypoint_exists = false
    stop_escaping()
  end

  c_persist.where = you.where()

  crawl.redraw_screen()
  print_information()

  if is_invisible_monster_present() then
    update_invisible_waypoint()
  end

  return true
end

function print_information()
  local threat_level = adjusted_threat()
  local channel = nil
  local message = "Danger: "

  message = message .. math.floor(danger_percent()) .. "% (" .. danger_text(threat_level) .. ")"

  if threat_level >= IMPOSSIBLE then
    channel = 6
  end

  print(message, channel)
  print_extra_hard_monsters()
end

function train()
    you.train_skill("Axes", 2)
    you.train_skill("Armour", 1)
    you.train_skill("Fighting", 1)
    you.train_skill("Dodging", 1)
end

function run(stepping)
  if is_scared() then

    if can_walk_away() then
      start_escaping()
    end

    stop_running()
    print("SCARED. CAN WALK AWAY: " .. tostring(can_walk_away()), 6)
  end

  if running or stepping then

    -- todo: clean this up

    if is_escaping() and escape() then
      return
    end

    if can_stair_dance() and escape() then
      return
    end

    if is_safe() then
      explore()
    else
      if not monster_present() then

        -- helps with clouds

        if not attempt_mini_explore() then
          stop_running()
        end
        return
      end

      if must_hand() then
        crawl.sendkeys("ab")
        return
      end

      if must_berserk() then
        crawl.sendkeys("aa")
        return
      end

      tab(true)
    end
  end
end

function step()
  run(true)
end

---------------------------------------------------------------------------
-- exploration                                                           --
---------------------------------------------------------------------------

function must_rest()
  return you.status("berserk cooldown") or
      hp_percent() < 100 or
      mp_percent() < 100 or
      you.slowed() or
      you.silencing() or
      you.confused() or
      you.status("barbed spikes") or
      you.status("marked") or
      you.corrosion() > 0 or
      has_bad_transformation()
end

function explore()
  if you.berserk() or must_rest() then
    if not attempt("5") then
      stop_running()
    end
    return
  end

  if remove_curse() then
    return
  end

  if identify_items() then
    return
  end

  if upgrade_equipment() then
    return
  end

  if remove_dangerous_rings() then
    return
  end

  if drop_junk() then
    return
  end

  if shafted() then
    unshaft()
    return
  end

  -- todo: this doesn't always work

  if you.depth() > cleared_depth() then
    if not attempt("o") then
      stop_running()
    end
	return
  end

  if not attempt_goal() then
    stop_running()
	return
  end
end

function attempt_mini_explore()
  return attempt("Xo." .. ESCAPE_KEY, "explore")
end

function is_up_stairs(x, y)
  local feature = view.feature_at(x, y)

  if feature then
    return feature:find("stone_stairs_up") or
        feature:find("escape_hatch_up") or
        feature:find("exit")
  end

  return false
end

function is_down_stairs(x, y)
  local feature = view.feature_at(x, y)
  if feature then
    return feature:find("stairs_down")
  end
  return false
end

function cleared_depth(branch)
  branch = branch or you.branch()
  return c_persist.cleared_depth[branch] or 0
end

function shafted()
  return you.depth() > cleared_depth() + 1
end

function unshaft()
  if not attempt_mini_escape() then
    if not attempt("o") then
      stop_running()
    end
  end
end

function attempt_goal()
  return attempt("G" .. goal() .. ENTER_KEY .. ENTER_KEY, "branch")
end

function goal()
  if c_persist.found["Temple"] and c_persist.cleared_depth["Temple"] ~= 1 then
    return "T"
  end

  if c_persist.found["Lair"] then
    if c_persist.cleared_depth["Lair"] ~= 6 then
      return "L" .. cleared_depth("Lair") + 1
    end

    if c_persist.found["Orc"] and c_persist.cleared_depth["Orc"] ~= 2 then
      return "O" .. cleared_depth("Orc") + 1
    end
  end

  if c_persist.cleared_depth["D"] ~= 15 then
      return "D" .. cleared_depth("D") + 1
  end

  return ""
end

---------------------------------------------------------------------------
-- combat                                                                --
---------------------------------------------------------------------------

function panic()

  -- todo: conditionally use hand, bia, ambrosia, healing, curing

  if not you.teleporting() and teleport() then return true end
  return false
end

function teleport()
  for item in inventory() do
    if item.class(true) == "scroll" and item.subtype() == "teleportation" then
      return read_scroll(items.index_to_letter(item.slot))
    end
  end

  return false
end

function can_read()
  if you.status():find("cannot breathe") then return false end
  return not you.silenced() and not you.confused() and not you.berserk()
end

function monsters(radius)
  local result = {}

  for _, a in ipairs(points(radius)) do
    local b = monster.get_monster_at(a.x, a.y)
    if b and not b:is_safe() then util.append(result, {b}) end
  end

  return result
end

function is_fearless()
  if not running then
    return false
  end
  -- todo: allow reckless fighting in some cases
end

function has_bad_transformation()
  if you.transform() == "" then
    return false
  end
  return true
end

function tab(is_reckless)
  if hp_percent() <= 50 and not is_reckless then
    print("You are too injured to fight recklessly!")
    return
  end

  if not avoid_dangerous_clouds() then
    stop_running()
    return
  end

  if is_invisible_monster_present() then
    if find_invisible(1) then
      crawl.sendkeys("*" .. to_key(find_invisible(1)))
      return
    end

    if not is_visible_monster_present() then
      if invisible_waypoint_exists then
        local x, y = travel.waypoint_delta(0)

        if x == 0 and y == 0 then
          invisible_waypoint_exists = false

          if not attempt_mini_escape() then
            stop_running()
          end
          return
        end

        if is_traversable(clamp(-x, -1, 1), clamp(-y, -1, 1)) then
          crawl.sendkeys(to_key(clamp(-x, -1, 1), clamp(-y, -1, 1)))
          return
        else
          invisible_waypoint_exists = false
        end
      end

      if not attempt_mini_escape() then
        stop_running()
      end

      return
    end
  end

  if you.confused() and hit_closest_monster() then
    return
  end

  crawl.sendkeys(TAB_KEY)
end

function wait()
  if must_rest() or
      you.berserk() or
      crawl.yesno("Are you sure you want to wait?", true, "n") then
    crawl.sendkeys("5")
  end
end

function must_berserk()
  -- todo: add better checks for if this ability is possible
  if is_safe() or not can_berserk() then
    return false
  end
  return is_angry()
end

function must_hand()
  -- todo: add better checks for if this ability is possible
  if is_safe() or
    you.piety_rank() < 2 or
    you.regenerating() or
    you.berserk() then
    return false
  end
  if find_monster("Sigmund") or find_monster("Grinder") then
    return true
  end
  return false
end

function must_start_escaping()
  -- return adjusted_threat() >= NIGHTMARE * 4 / 3
  return false
end


function can_walk_away()
  -- this is just a starting point, and needs to be improved

  if can_stair_dance() then return true end

  if you.depth() <= cleared_depth() then return false end

  if true then return true end

  -- todo: in some cases you can walk away while berserk or slow

  if you.berserk() or you.slowed() or util.exists(monsters(1), is_fast_monster) then return false end

  local predicate = function(monster)
    return monster:has_known_ranged_attack()
  end

  -- todo: in some cases you can walk away from monsters with ranged attacks

  if length(where(monsters(), predicate)) > 0 then return false end

  return true
end

function can_stair_dance()
  if you.absdepth() == 1 or not can_see_up_stairs() then return false end

  -- prevents stair dancing if only undead monsters are adjacent

  local can_not_use_stairs = function(monster)
    return not can_use_stairs(monster)
  end

  if count_monsters(1, can_use_stairs) == 0 and count_monsters(1, can_not_use_stairs) > 0 then
    return false
  end

  local result = count_monsters() > count_monsters(1)

  -- prevents infinite stair dancing loops

  if result then
    local monster = closest_monster()
    local previous = c_persist.dancing
    local current = {name = monster:name(), count = 1}

    if previous and previous.name == current.name then
      previous.count = previous.count + 1
	  if previous.count >= 20 then return false end
    else
      c_persist.dancing = current
    end

    return true
  end

  return false
end

function can_use_stairs(monster)
  return not monster:desc(true):find("incapable of using stairs")
end

function can_see_up_stairs(radius)
  local predicate = function(point)
    return is_up_stairs(point.x, point.y) and you.see_cell_no_trans(point.x, point.y)
  end

  return length(where(points(radius), predicate)) > 0
end

function is_fast_monster(monster)
  return monster:speed_description():find("fast")
end

function is_monster(monster, pattern)
  return monster:name():find(pattern)
end

function find_monster(pattern, radius)
  return first(where(monsters(radius), function(monster) return is_monster(monster, pattern) end))
end

function count_monsters(radius, f)
  if f then return length(where(monsters(radius), f)) end
  return length(monsters(radius))
end

function is_angry()
  local adjacent = adjusted_threat(1)
  local total = adjusted_threat()

  -- berserk is used at 75% health against monsters with yellow names

  return adjacent >= MEDIUM and total >= MEDIUM * 4 / 3
end

function can_berserk()
  return you.god() == "Trog" and
      you.piety_rank() > 0 and
      not you.berserk() and
      not you.status("berserk cooldown") and
      not you.confused() and
      not you.silenced() and
      not you.mesmerised() and
      not you.status("afraid") and
      not you.caught()
end

function is_scared()
  if you.poison_survival() < 1 then
    return true
  end
  if not is_safe() then
    if you.status("barbed spikes") or
        has_bad_transformation() then
      return true
    end
    if not is_fearless() then
       -- experimental
      return adjusted_threat() >= NIGHTMARE
    end
  end
  return false
end

function has_spell(monster, name)
  local is_matching_spell = function(spell)
    return spell:find(name)
  end

  local is_matching_book = function(book)
    return util.exists(book, is_matching_spell)
  end

  return util.exists(monster:spells(), is_matching_book)
end

function has_electrocution_weapon(monster)
  return monster:desc(true):find("of electrocution%.")
end

function has_chaos_weapon(monster)
  return monster:desc(true):find("of chaos%.")
end

function has_distortion_weapon(monster)
  return monster:desc(true):find("of distortion%.")
end

function threat(radius)
  radius = radius or 8
  local result = 0
  local invisible_threat = 0
  for a = -radius, radius do
    for b = -radius, radius do
      local x, y = guess_invisible()
      if x == a and y == b then
        invisible_threat = calculate_invisible_threat()
      else
        local c = monster.get_monster_at(a, b)
        if c and not c.is_safe(c) then
          result = result + calculate_threat(c)
        end
      end
    end
  end
  if is_invisible_monster_present() and
      invisible_threat == 0 and
      radius == 8 then
    invisible_threat = calculate_invisible_threat()
  end
  return result + invisible_threat
end

function adjusted_threat(radius)
  local multiplier = 1
  if you.slowed() then multiplier = multiplier + 1 end
  if you.poisoned() then multiplier = multiplier + 1 end
  if you.corrosion() > 0 then multiplier = multiplier + 1 end
  return threat(radius) * multiplier * 100 / hp_percent()
end

function danger_percent()
  return math.min(adjusted_threat() * 100 / IMPOSSIBLE, 999)
end

function danger_text(value)
  if value >= IMPOSSIBLE then return "impossible" end
  if value >= NIGHTMARE then return "nightmare" end
  if value >= HARD then return "hard" end
  if value >= MEDIUM then return "medium" end
  if value >= EASY then return "easy" end
  if value >= POPCORN then return "popcorn" end
  return "safe"
end

function is_extra_hard(target)
  return calculate_threat(target) > 2 ^ target:threat()
end

function print_extra_hard_monsters(radius)
  local f = function(monster)
    print(monster:name() .. " (" .. danger_text(calculate_threat(monster)) .. ")", 6)
  end

  util.foreach(where(monsters(radius), is_extra_hard), f)
end

function calculate_threat(target)
  local hard = {"Natasha"}

  -- early game

  util.append(hard, {"worm", "gnoll"})

  -- mid game

  util.append(hard, {"dream sheep", "hydra", "manticore"})

  -- late game

  util.append(hard, {"ugly thing", "boggart", "lurking horror"})

  -- giants

  util.append(hard, {"ogre", "cyclops", "ettin", "titan", "juggernaut"})

  -- resistances

  if not (you.res_poison() > 0) then
    util.append(hard, {"adder"})
  end

  if not (you.res_shock() > 0) then
    util.append(hard, {"sky beast", "electric eel", "shock serpent", "spark wasp", "electric golem"})
  end

  if not you.res_corr() then
    util.append(hard, {"jelly"})
  end

  local result = target:threat()

  for _, name in ipairs(hard) do
    if target:name():find(name) then
      result = result + 1
    end
  end

  -- spells and abilities

  if target:is("berserk") or
      has_spell(target, "Smiting") or
      has_spell(target, "Banishment") or
      has_spell(target, "Petrify") or
      has_spell(target, "Petrifying Cloud") or
      has_spell(target, "Paralyse") or
      has_spell(target, "Paralysis Gaze") or
      has_spell(target, "Hurl Damnation") or
      has_spell(target, "Call Down Damnation") or
      has_spell(target, "Symbol of Torment") or
      has_spell(target, "Agony Range") or
      has_spell(target, "Flay") then
    result = result + 1
  end

  -- weapons

  if has_electrocution_weapon(target) or has_chaos_weapon(target) or has_distortion_weapon(target) then
    result = math.max(result, 3)
  end

  return 2 ^ result
end

function calculate_invisible_threat()
  -- todo: use invisible_monster_name to calcualte threat
  if is_invisible_monster_present() then
    return HARD
  end
  return 0
end

function is_visible_monster_present(radius)
  return length(monsters(radius)) > 0
end

function monster_present()
  return not is_visible_monster_present() and is_invisible_monster_present()
end

function is_safe()
  return you.feel_safe() and not monster_present()
end

function hp_percent()
  local a, b = you.hp()
  return 100 * (you.poison_survival() or a) / b
end

function mp_percent()
  local a, b = you.mp()
  return 100 * a / b
end

function closest_monster(radius)
  local less_than = function(left, right)
    local left_distance = distance(left:pos())
	local right_distance = distance(right:pos())

    if left_distance == right_distance then
	  return calculate_threat(left) < calculate_threat(right)
	end

    return left_distance < right_distance
  end

  local t = monsters(radius)
  table.sort(t, less_than)
  return first(t)
end

function hit_closest_monster()
  local target = closest_monster()
  if target then
    local x, y = target.pos(target)
    if distance(x, y) == 1 then
      crawl.sendkeys("*" .. to_key(x, y))
      return true
    end
    return approach(x, y)
  end
  return false
end

function approach(x, y)
  if distance(x, y) == 1 and not is_traversable(x, y) then
    return false
  end
  for a = -1, 1 do
    for b = -1, 1 do
      if cartesian_distance(x, y, a, b) < cartesian_distance(x, y)
          and is_traversable(a, b) then
        return attempt(to_key(a, b), "approach")
      end
    end
  end
  return false
end

function is_traversable(x, y)
  return travel.feature_traversable(view.feature_at(x, y)) and
      not monster.get_monster_at(x, y) and
      view.cloud_at(x, y) ~= "calcifying dust"
end

function invisible_monsters(radius)
  return where(points(radius), function(point) return view.invisible_monster(point.x, point.y) end)
end

function find_invisible(radius)
  local point = first(invisible_monsters(radius))
  return point.x, point.y
end

function guess_invisible()
  if invisible_waypoint_exists then
    local x, y = travel.waypoint_delta(0)

    if x and y then
      return -x, -y
    end
  end
end

function is_invisible_monster_present()
  return not options.autopick_on or length(invisible_monsters()) > 0
end

function update_invisible_waypoint()
  local x, y = find_invisible()
  if x and y then
    travel.set_waypoint(0, x, y)
    invisible_waypoint_exists = true
  end
end

function avoid_dangerous_clouds()
  local cloud = view.cloud_at(0, 0)
  -- handles catoblepas
  if cloud == "calcifying dust" then
    local target = closest_monster()
    if not target then
      return attempt_mini_explore()
    end
    return approach(closest_adjacent_traversable(target:pos()))
  end
  return true
end

function closest_adjacent_traversable(x, y)
  local adjacent = {}
  for a = -1, 1 do
    for b = -1, 1 do
      if not (a == 0 and b == 0) and is_traversable(a, b) then
        local cell = point(a, b)
        adjacent[table.getn(adjacent) + 1] = cell
      end
    end
  end
  if table.getn(adjacent) > 0 then
    table.sort(adjacent, function(p0, p1)
      return distance(p0.x, p0.y, x, y) < distance(p1.x, p1.y, x, y)
    end)
    return adjacent[1].x, adjacent[1].y
  end
end

---------------------------------------------------------------------------
-- complex combat                                                        --
---------------------------------------------------------------------------

-- todo

---------------------------------------------------------------------------
-- escaping                                                              --
---------------------------------------------------------------------------

function is_escaping()
  return c_persist.flags["escaping"] or false
end

function start_escaping()
  c_persist.flags["escaping"] = true
end

function stop_escaping()
  c_persist.flags["escaping"] = false
end

function attempt_mini_escape()
  -- does not avoid bumping into monsters
  if view.feature_at(0, 0) == "exit_dungeon" then
    return false
  end
  if is_up_stairs(0, 0) then
    return attempt("<", "escape")
  end
  return attempt("X<." .. ESCAPE_KEY, "escape")
end

function escape()
  if you.absdepth() == 1 and not you.have_orb() then return false end
  if is_up_stairs(0, 0) then return attempt("<", "escape") end
  local stairs = where(points(1), function(p) return is_up_stairs(p.x, p.y) end)

  if length(stairs) > 0 then
    local traversable_stairs = where(stairs, function(p) return is_traversable(p.x, p.y) end)
    local p = first(traversable_stairs)
	if not p then return false end
    return attempt(to_key(p.x, p.y), "escape")
  end

  c_persist.flags["exclude"] = true
  return attempt("X<." .. ESCAPE_KEY, "escape")
end

function exclude_monsters()
  for a = -8, 8 do
    for b = -8, 8 do
      local c = monster.get_monster_at(a, b)
      if c then
        travel.set_exclude(c:x_pos(), c:y_pos(), 0)
      end
    end
  end
end

function clear_exclusions()
  crawl.sendkeys("X" .. control("e") .. ESCAPE_KEY)
end

function any_traversable(cells)
  for _, cell in ipairs(cells) do
    if is_traversable(cell.x, cell.y) then
      return cell
    end
  end
end

function all_adjacent_up_stairs()
  local adjacent = {}
  for a = -1, 1 do
    for b = -1, 1 do
      if not (a == 0 and b == 0) and is_up_stairs(a, b) then
        adjacent[table.getn(adjacent) + 1] = point(a, b)
      end
    end
  end
  return adjacent
end

---------------------------------------------------------------------------
-- item dropping                                                         --
---------------------------------------------------------------------------

function drop(item)
  local letter = items.index_to_letter(item.slot)
  crawl.sendkeys("d" .. letter .. ENTER_KEY)
end

function can_drop_if_burdened(item)
  if item.class(true) == "wand" and
      item.subtype() ~= "digging" then
    for other in inventory() do
      -- keep if there is a worse wand that can be dropped instead
      if other.class(true) == "wand" and wand_level(other) < wand_level(item) then
        return false
      end
    end
    return true
  end
  return false
end

function drop_junk()
  for item in inventory() do
    if is_junk(item) then
      if not (item.cursed and item.equipped) then
        drop(item)
        return true
      end
    end
  end
  return false
end

function is_junk_weapon(item)
  if item.class(true) == "weapon" then
    if not uses_weapon_skill(item) or god_hates(item) then
      return true
    end
    for other in inventory() do
      if not god_hates(other) and compare_weapons(item, other) < 0 then
        return true
      end
    end
  end
  return false
end

function god_hates(item)
  if you.god() == "Trog" and item:ego() == "pain" then
    return true
  end
  return false
end

function is_junk_armour(item)
  if is_scales(item) then
    return false
  end
  if item:ego() == "harm" then
    return true
  end
  if item.class(true) == "armour" then
    for other in inventory() do
      if compare_armour(item, other) < 0 then
        return true
      end
    end
  end
  return false
end

function is_junk_amulet(item)
  if is_amulet(item) then
    if item.subtype() == "amulet of inaccuracy" then
      return true
    end
    if item.equipped and is_faith_bound() then
      return false
    end
    for other in inventory() do
      if compare_amulets(item, other) < 0 then
        return true
      end
    end
  end
  return false
end

function is_junk_ring(item)
  if is_ring(item) then
    if item.subtype() == "ring of teleportation" or
        item.subtype() == "ring of attention" then
      return true
    end
    if item.plus and item.plus < 0 then
      return true
    end
  end
  return false
end

function is_dangerous(item)
  if is_ring(item) then
    return item.subtype() == "ring of fire" or
        item.subtype() == "ring of ice"
  end
  if is_scales(item) then
    return item:name():find("fire dragon scales") or
        item:name():find("ice dragon scales")
  end
  return false
end

function is_junk(item)
  if item.artefact then
    return false
  end
  if is_junk_weapon(item) or
      is_junk_armour(item) or
      is_junk_amulet(item) or
      is_junk_ring(item) or
      is_unneeded_duplicate(item) then
    return true
  end
  if burdened() and can_drop_if_burdened(item) then
    return true
  end
  local junk_subtypes = {
    --"brilliance",
    --"holy word",
    --"silence",
    "attraction",
    "degeneration",
    "lignification",
    "immolation",
    "noise",
    "random uselessness",
    "torment",
    "vulnerability"}
  for _, subtype in ipairs(junk_subtypes) do
    if item.subtype() == subtype then 
      return true
    end
  end
  return false
end

---------------------------------------------------------------------------
-- autopickup                                                            --
---------------------------------------------------------------------------

function is_unneeded_duplicate(item)
  if item.artefact or
      item.equipped or
      item.class(true) == "missile" or
      item.class(true) == "potion" or
      item.class(true) == "scroll" then
    return false
  end
  for other in inventory() do
    if item.slot ~= other.slot and
        other:name() == item:name() and
        item:ego() == other:ego() and
        (item.plus or 0) == (other.plus or 0) then
      return true
    end
  end
  return false
end

function want_weapon(item)
  if item.subtype() == "hand axe" and not item.fully_identified then
    -- avoids early cursed hand axes
    return false
  end
  if item.class(true) == "weapon" then
    local best = best_damage(item.weap_skill)
    if item.damage > best then
      return true
    end
    if item.damage == best then
      return item.branded
    end
  end
  return false
end

function want_armour(item)
  if is_scales(item) then
    return true
  end

  -- todo: this currently ignores branded robes

  if item.class(true) == "armour" then
    local best = best_ac(item.subtype())
    if item.ac > best then
      return true
    end

    if item.subtype() == "helmet" or
        item.subtype() == "cloak" or
        item.subtype() == "gloves" or
        item.subtype() == "boots" then
      return item.branded
    end
  end

  return false
end

function best_armour_to_enchant()
  -- todo: handle shields
  -- todo: handle body armours
  local boots = items.equipped_at("Boots")
  if boots and (boots.plus or 0) < 2 and not boots.artefact then
    return boots
  end
  local gloves = items.equipped_at("Gloves")
  if gloves and (gloves.plus or 0) < 2 and not gloves.artefact then
    return gloves
  end
  local helmet = items.equipped_at("Helmet")
  if helmet and (helmet.plus or 0) < 2 and not helmet.artefact then
    return helmet
  end
  local cloak = items.equipped_at("Cloak")
  if cloak and cloak.ac > 0
      and (cloak.plus or 0) < 2 and
      not cloak.artefact then
    return cloak
  end
  local body = items.equipped_at("Armour")
  if body and (body.plus or 0) < 2 and not body.artefact then
    return body
  end
  -- local shield = items.equipped_at("Shield")
end

function want_book(item)
  return item.class(true) == "book" and not item.is_useless
end

function autopickup(item, name)
  if is_unneeded_duplicate(item) or
      is_slot_missing(item) or
      is_junk(item) then
    return false
  end
  if item.artefact then
    return true
  end
  if want_book(item) then
    return true
  end
  if want_weapon(item) then
    return true
  end
  if want_armour(item) then
    return true
  end
end

add_autopickup_func(autopickup)

---------------------------------------------------------------------------
-- curse removal                                                         --
---------------------------------------------------------------------------

function scroll_of_remove_curse_letter()
  for item in inventory() do
    if item.class(true) == "scroll" and
        item.subtype() == "remove curse" then
      return items.index_to_letter(item.slot)
    end
  end
end

function remove_curse()
  local rc_letter = scroll_of_remove_curse_letter()
  if rc_letter then
    for item in inventory() do
      if item.cursed and item.equipped then
        return read_scroll(rc_letter)
      end
    end
  end
  return false
end

---------------------------------------------------------------------------
-- item identification                                                   --
---------------------------------------------------------------------------

function scroll_of_identify_letter()
  for item in inventory() do
    if item.class(true) == "scroll" and item.subtype() == "identify" then
      return items.index_to_letter(item.slot)
    end
  end
end

function scroll_of_blinking_letter()
  for item in inventory() do
    if item.class(true) == "scroll" and item.subtype() == "blinking" then
      return items.index_to_letter(item.slot)
    end
  end
end

function want_to_identify_with_scroll(item)
  if not item.fully_identified and not item.artefact then
    if is_faith_equipped() and is_amulet(item) then
      return true
    end
    if item.class(true) == "potion" then
      return true
    end
    if item.class(true) == "scroll" and
        scroll_of_identify_quantity() > 5 then
      return true
    end
  end
  return false
end

function want_to_use_scroll_of_identify()
  for item in inventory() do
    if want_to_identify_with_scroll(item) then
      return true
    end
  end
  return false
end

function scroll_of_identify_quantity()
  for item in inventory() do
    if item.class(true) == "scroll" and item.subtype() == "identify" then
      return item.quantity
    end
  end
  return 0
end

function identify_items()
  local id_letter = scroll_of_identify_letter() 
  for item in inventory() do
    if item.class(true) == "scroll" and
        not item.fully_identified and
        item.quantity > 1 and
        (c_persist.found["scroll of identify"] or want_to_use_scroll_of_identify()) then
      return read_scroll(items.index_to_letter(item.slot))
    end
  end
  if id_letter then
    for item in inventory() do
      if want_to_identify_with_scroll(item) then
        return read_scroll(id_letter .. items.index_to_letter(item.slot))
      end
    end
  end
  return false
end

---------------------------------------------------------------------------
-- item utility                                                          --
---------------------------------------------------------------------------

function inventory()
  return iter.invent_iterator:new(items.inventory())
end

function burdened()
  return table.getn(items.inventory()) > 47
end

function read_scroll(letter)
  if can_read() then
    crawl.sendkeys("r" .. letter)
    return true
  end

  return false
end

---------------------------------------------------------------------------
-- equipment utility                                                     --
---------------------------------------------------------------------------

function uses_weapon_skill(item)
  return item.class(true) == "weapon" and item.weap_skill == "Axes"
end

function is_amulet(item)
  if item.class(true) == "jewellery" then
    return item.name():find("amulet") or item.name():find("necklace")
  end
  return false
end

function is_ring(item)
  if item.class(true) == "jewellery" then
    return item.name():find("ring")
  end
  return false
end

function is_scales(item)
  return item.name():find("scales")
end

function compare_amulets(left, right)
  -- todo: handle artefacts
  if left.artefact or right.artefact then
    return 0
  end
  if not is_amulet(left) or not is_amulet(right) then
    return 0
  end
  if not left.fully_identified or not right.fully_identified then
    return 0
  end
  return compare(amulet_level(left), amulet_level(right))
end

function amulet_level(amulet)
  if amulet.subtype() == "amulet of regeneration" then
    return 6
  end
  if amulet.subtype() == "amulet of guardian spirit" then
    return 5
  end
  if amulet.subtype() == "amulet of faith" then
    return 4
  end
  if amulet.subtype() == "amulet of the acrobat" then
    return 3
  end
  if amulet.subtype() == "amulet of reflection" then
    return 2
  end
  if amulet.subtype() == "amulet of magic regeneration" then
    return 1
  end
  return 0
end

function compare_rings(left, right)
  -- todo: handle artefacts
  if left.artefact or right.artefact then
    return 0
  end
  if not is_ring(left) or not is_ring(right) then
    return 0
  end
  if not left.fully_identified or not right.fully_identified then
    return 0
  end
  return compare(ring_level(left), ring_level(right))
end

function ring_level(ring)
  -- todo: add better ring logic
  if ring.subtype() == "ring of see invisible" then
    return 0
  end
  if ring.subtype() == "ring of poison resistance" then
    return 0
  end
  if ring.subtype() == "ring of protection from fire" then
    return 0
  end
  if ring.subtype() == "ring of protection from cold" then
    return 0
  end
  if ring.subtype() == "ring of resist corrosion" then
    return 0
  end
  if ring.subtype() == "ring of positive energy" then
    return 0
  end
  if ring.subtype() == "ring of slaying" then
    return 7
  end
  if ring.subtype() == "ring of protection" then
    return 6
  end
  if ring.subtype() == "ring of evasion" then
    return 5
  end
  if ring.subtype() == "ring of willpower" then
    return 4
  end
  if ring.subtype() == "ring of stealth" then
    return 3
  end
  if ring.subtype() == "ring of strength" then
    return 2
  end
  if ring.subtype() == "ring of dexterity" then
    return 1
  end
  -- flight, magical power, wizardry, intelligence, fire, ice
  return 0
end

function wand_level(wand)
  if wand.subtype() == "digging" then
    return 9
  end
  if wand.subtype() == "acid" then
    return 8
  end
  if wand.subtype() == "iceblast" then
    return 7
  end
  if wand.subtype() == "paralysis" then
    return 6
  end
  if wand.subtype() == "enslavement" then
    return 5
  end
  if wand.subtype() == "disintegration" then
    return 4
  end
  if wand.subtype() == "flame" then
    return 3
  end
  if wand.subtype() == "polymorph" then
    return 2
  end
  if wand.subtype() == "random effects" then
    return 1
  end
  return 0
end

function helmet_level(item)
  if item:ego() == "see invisible" then
    return 2
  end
  if item:ego() == "willpower" then
    return 1
  end
  -- don't care about intelligence
  if item:ego() == "intelligence" then
    return 0
  end
  -- don't care about other brands
  return 0
end

function cloak_level(item)
  if item:ego() == "resistance" then
    return 5
  end
  if item:ego() == "poison resistance" then
    return 4
  end
  if item:ego() == "preservation" then
    return 4
  end
  if item:ego() == "fire resistance" then
    return 4
  end
  if item:ego() == "cold resistance" then
    return 4
  end
  if item:ego() == "repulsion" then
    return 3
  end
  if item:ego() == "willpower" then
    return 2
  end
  if item:ego() == "stealth" then
    return 1
  end
  -- don't care about invisibility
  if item:ego() == "invisibility" then
    return 0
  end
  -- harm is junk
  if item:ego() == "harm" then
    return -1
  end
  -- don't care about other brands
  return 0
end

function boots_level(item)
  if item:ego() == "running" then
    return 3
  end
  if item:ego() == "flying" then
    return 2
  end
  if item:ego() == "stealth" then
    return 1
  end
  -- don't care about other brands
  return 0
end

function gloves_level(item)
  if item:ego() == "strength" then
    return 2
  end
  if item:ego() == "dexterity" then
    return 1
  end
  -- don't care about archery
  if item:ego() == "archery" then
    return 0
  end
  -- don't care about other brands
  return 0
end

function body_level(item)
  if item:name():find("gold dragon scales") then
    return 1
  end
  if item:name():find("storm dragon scales") then
    return 1
  end
  if item:name():find("shadow dragon scales") then
    return 1
  end
  if item:name():find("pearl dragon scales") then
    return 1
  end
  -- fire and ice scales are dangerous
  if item:name():find("fire dragon scales") then
    return -1
  end
  if item:name():find("ice dragon scales") then
    return -1
  end
  -- don't care about other types
  return 0
end

function is_faith_equipped()
  local amulet = items.equipped_at("Amulet")
  return amulet and amulet.subtype() == "amulet of faith"
end

function is_faith_bound()
  return is_faith_equipped() and you.piety_rank() < 6
end

function equip_ring(item, letter)
  if is_ring(item) and not item.equipped then
    if is_ring_missing() then
      crawl.sendkeys("P" .. items.index_to_letter(item.slot))
      return true
    end
    local left = items.equipped_at("Left Ring")
    local right = items.equipped_at("Right Ring")
    if left.cursed and right.cursed then
      return false
    end
    if left.cursed or right.cursed then
      crawl.sendkeys("P" .. items.index_to_letter(item.slot))
      return true
    end
    if left.subtype() == right.subtype() and left.plus == right.plus then
      crawl.sendkeys("P" .. items.index_to_letter(item.slot))
      return true
    end
    if compare_rings(left, right) > 0 then
      letter = letter or ">"
    else
      letter = letter or "<"
    end
    crawl.sendkeys("P" .. items.index_to_letter(item.slot) .. letter)
    return true
  end
  return false
end

function is_ring_missing()
  return not items.equipped_at("Left Ring") or not items.equipped_at("Right Ring")
end

function equipped_at(subtype)
  local translations = {
    cloak = "Cloak",
    helmet = "Helmet",
    gloves = "Gloves",
    boots = "Boots",
    body = "Armour",
    shield = "Shield"}
  return items.equipped_at(translations[subtype])
end

function is_slot_missing(item)
  if item.class(true) == "armour" then
    return item.subtype() == "shield" or item.name():find("barding")
  end
  return false
end

function upgrade_equipment()
  for item in inventory() do
    if not item.equipped and
        not item.artefact and
        not is_dangerous(item) and
        not is_slot_missing(item) and
        not is_junk(item) then
      if item.class(true) == "weapon" then
        local equipped = items.equipped_at("Weapon")
        if not equipped or
            not item.fully_identified or
            compare_weapons(item, equipped) > 0 then
          if not (equipped and equipped.cursed) and
              item.wield() then
            return true
          end
        end
      end
      if item.class(true) == "armour" then
        local equipped = equipped_at(item.subtype())
        if not equipped or
            not item.fully_identified or
            compare_armour(item, equipped) > 0 then
          if not (equipped and equipped.cursed) and
              item.wear() then
            return true
          end
        end
      end
      if is_amulet(item) then
        local equipped = items.equipped_at("Amulet")
        if not equipped or
            not item.fully_identified and not is_faith_equipped() or
            compare_amulets(item, equipped) > 0 then
          if not (equipped and equipped.cursed)
              and not is_faith_bound() then
            crawl.sendkeys("P" .. items.index_to_letter(item.slot))
            return true
          end
        end
      end
      -- rings are not fully supported yet
      if is_ring(item) then
        if is_ring_missing() or
            not item.fully_identified then
          if equip_ring(item) then
            return true
          end
        end
        local left = items.equipped_at("Left Ring")
        if not (left and left.cursed) and
            compare_rings(item, left) > 0 and
            equip_ring(item) then
          return true
        end
        local right = items.equipped_at("Right Ring")
        if not (right and right.cursed) and
            compare_rings(item, right) > 0 and
            equip_ring(item) then
          return true
        end
      end
    end
  end
  return false
end

function remove_dangerous_rings()
  for item in inventory() do
    if item.equipped and
        not item.cursed and
        is_ring(item) and
        is_dangerous(item) then
      if item.remove() then
        return true
      end
    end
  end
  return false
end

---------------------------------------------------------------------------
-- weapon and armour utility                                             -- 
---------------------------------------------------------------------------

function compare_weapons(left, right)
  -- todo: handle artefacts
  if left.artefact or right.artefact then
    return 0
  end
  if left.is_useless or right.is_useless then
    return 0
  end
  if left.class(true) ~= "weapon" or right.class(true) ~= "weapon" then
    return 0
  end
  if left.weap_skill ~= right.weap_skill then
    return 0
  end
  if not left.fully_identified or not right.fully_identified then
    return 0
  end
  local result = compare(left.damage, right.damage)
  if result ~= 0 then return result end
  result = compare(weapon_brand_level(left:ego()), weapon_brand_level(right:ego()))
  if result ~= 0 then return result end
  return compare(left.plus or 0, right.plus or 0)
end

function weapon_brand_level(brand)
  local extended = false
  if brand == "holy wrath" then
    if extended then
      return 9
    end
    return 0
  end
  if brand == "vampirism" then
    if extended then
      return 0
    end
    return 9
  end
  if brand == "electrocution" then
    return 8
  end
  if brand == "flaming" then
    return 7
  end
  if brand == "freezing" then
    return 6
  end
  if brand == "draining" then
    return 5
  end
  if brand == "venom" then
    return 4
  end
  if brand == "vorpality" then
    return 3
  end
  if brand == "protection" then
    return 2
  end
  if brand == "antimagic" then
    return 1
  end
  if not brand then
    return 0
  end
  if brand == "chaos" then
    return -1
  end
  if brand == "distortion" then
    return -2
  end
  if brand == "pain" then
    return -3
  end
  -- unknown brands
  return -4
end

function compare_armour(left, right)
  -- todo: handle artefacts
  if left.artefact or right.artefact then
    return 0
  end
  if left.is_useless or right.is_useless then
    return 0
  end
  if not left.class(true) == "armour" or
      not right.class(true) == "armour" then
    return 0
  end
  if left.subtype() ~= right.subtype() then
    return 0
  end
  if not left.fully_identified or not right.fully_identified then
    return 0
  end
  result = 0
  if left.subtype() == "body" then
    result = compare(body_level(left), body_level(right))
  elseif left.subtype() == "helmet" then
    result = compare(helmet_level(left), helmet_level(right))
  elseif left.subtype() == "cloak" then
    result = compare(cloak_level(left), cloak_level(right))
  elseif left.subtype() == "gloves" then
    result = compare(boots_level(left), boots_level(right))
  elseif left.subtype() == "boots" then
    result = compare(gloves_level(left), gloves_level(right))
  end
  if not (result == 0) then
    return result
  end
  return compare(left.ac + (left.plus or 0), right.ac + (right.plus or 0))
end

function best_damage(weap_skill)
  local result = 0
  for item in inventory() do
    if item.weap_skill == weap_skill and item.damage > result then
      result = item.damage
    end
  end
  return result
end

function best_ac(subtype)
  local result = 0
  for item in inventory() do
    if item.subtype() == subtype and item.ac > result then
      result = item.ac
    end
  end
  return result
end

---------------------------------------------------------------------------
-- general utility                                                       --
---------------------------------------------------------------------------

function print(value, channel)
  crawl.mpr(tostring(value), channel)
end

function point_to_string(point)
  if point == nil then return tostring(nil) end
  return "(" .. point.x .. ", " .. point.y .. ")"
end

function monster_to_string(monster)
  if monster == nil then return tostring(nil) end
  return monster:name()
end

function to_key(x, y)
  local keys = {"b", "j", "n", "h", "s", "l", "y", "k", "u"}
  return keys[5 + x - 3 * y]
end

function control(letter)
  return string.char(string.byte(letter) - string.byte("a") + 1)
end

function compare(left, right)
  if left < right then return -1 end
  if left > right then return 1 end
  return 0
end

function clamp(value, min, max)
  if value < min then return min end
  if value > max then return max end
  return value
end

function point(a, b)
  return {x = a, y = b}
end

function points(radius)
  radius = radius or 8
  local result = {}

  for x = -radius, radius do
    for y = -radius, radius do
      util.append(result, {point(x, y)})
    end
  end

  return result
end

function distance(x0, y0, x1, y1)
  return math.max(math.abs(x0 - (x1 or 0)), math.abs(y0 - (y1 or 0)))
end

function cartesian_distance(x0, y0, x1, y1)
  return math.sqrt((x0 - (x1 or 0)) ^ 2 + (y0 - (y1 or 0)) ^ 2)
end

function length(t)
  return table.getn(t)
end

function first(t)
  return t[1]
end

function where(t, f)
  local result = {}

  for _, a in ipairs(t) do
    if f(a) then util.append(result, {a}) end
  end

  return result
end

function map(t, f)
  local result = {}

  for _, a in ipairs(t) do
    util.append(result, {f(a)})
  end

  return result
end

---------------------------------------------------------------------------
-- hooks                                                                 --
---------------------------------------------------------------------------

function c_answer_prompt(prompt)
  if prompt:find("Keep equipping") then
    return true
  end
  if prompt:find("Keep disrobing") then
    return false
  end
  if prompt:find("Really walk") then
    return true
  end
  if prompt:find("Really attack") then
    stop_running()
    return false
  end
  if prompt:find("Really unwield") or
      prompt:find("Really take off") or
      prompt:find("Really remove") or
      prompt:find("Really wield") or
      prompt:find("Really wear") or
      prompt:find("Really put on") then
    return true
  end
end

function c_message(text, channel)
  if channel == "error" then
    stop_running()
    return
  end

  if text:find("would you want") or text:find("too confused") then
   -- too confused happens when a monster goes invisible while confused and you don't know
   -- the location. need to keep track of pre-invisible monster locations better to prevent this

    stop_running()
    return
  end

  if text:find("suddenly seem different") then
    invisible_monster_name = nil
    invisible_waypoint_exists = false
    stop_escaping()
    return
  end

  if text:find("to the Ecumenical Temple") then
    c_persist.found["Temple"] = true
    return
  end

  if text:find("to the Lair") then
    c_persist.found["Lair"] = true
    return
  end

  if text:find("to the Orc") then
    c_persist.found["Orc"] = true
    return
  end

  if text:find("explore") or text:find("exploring") then
    if you.depth() == cleared_depth() + 1 then
      c_persist.cleared_depth[you.branch()] = you.depth()
    end

    return
  end

  if text:find("reachable target") or text:find("move towards target") then

    -- todo: add logic to handle unreachable electric eels

    if not attempt_mini_explore() and not attempt_goal() then

      -- todo: handle being stuck

      stop_running()
    end

    return
  end

  if text:find("There is an entrance") and view.feature_at(0, 0) == "enter_shop" then
    crawl.sendkeys(ESCAPE_KEY)
    return
  end

  -- item identification

  if text:find("is a scroll of identify") then
    c_persist.found["scroll of identify"] = true

    for item in inventory() do
      if want_to_identify_with_scroll(item) then
        crawl.sendkeys(items.index_to_letter(item.slot))
        return
      end
    end

    return
  end

  if text:find("is a scroll of enchant weapon") then
    local equipped = items.equipped_at("Weapon")

    if equipped and not equipped.artefact then
      if (equipped.plus or 0) < 9 then
        crawl.sendkeys(items.index_to_letter(equipped.slot))
        return
      end
    end

    return
  end

  if text:find("is a scroll of enchant armour") then
    local equipped = best_armour_to_enchant()

    if equipped then
      crawl.sendkeys(items.index_to_letter(equipped.slot))
    end

    return
  end

  if text:find("Blink to where?") then
    if not scroll_of_blinking_letter() then
      crawl.sendkeys("fy")
    end

    return
  end

  -- invisible monsters

  if text:find("the .* flickers and vanishes") then
    local _, _, match = text:find("the (.*) flickers and vanishes")
    invisible_monster_name = match
    return
  end

  if text:find(".* flickers and vanishes") then
    local _, _, match = text:find("(.*) flickers and vanishes")
    invisible_monster_name = match
    return
  end

  if text:find("the .* flickers out of sight") then
    local _, _, match = text:find("the (.*) flickers out of sight")
    invisible_monster_name = match
    return
  end

  if text:find("Reactivating autopickup") then
    invisible_monster_name = nil
    invisible_waypoint_exists = false
    return
  end
end

function choose_stat_gain()
  return "i"
end

---------------------------------------------------------------------------
-- debug                                                                 --
---------------------------------------------------------------------------

function debug_escape()
  if is_up_stairs(0, 0) then
    print("ON STAIRS!")
    return
  end
  if not is_escaping() then
    start_escaping()
  end
  step()
end

function debug()
  if find_monster("foo") then print("FOO!") end
end

function ch_start_running(kind)
  if kind == "intertravel" and c_persist.flags["exclude"] then
    exclude_monsters()
  end
end

}

macros += M c ===debug
macros += M 0 ===debug_escape