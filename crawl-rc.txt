# DCSS 0.26

# todo: bind . to prompt for waiting a turn?
# todo: handle non-hostile enemies, breaks explore
# use adjacent enemies to calculate berserk
# if last message is "it is a..." you can handle the logic
# use the jewellery_prompt option?
# can delete waypoints with ctrl+W
# use the c_message hook instead of searching last message!

############################################################################
# options                                                                  #
############################################################################

# prevents accidental resting or abilities

bindkey = [s] CMD_NO_CMD_DEFAULT
bindkey = [p] CMD_NO_CMD_DEFAULT

# speeds up gameplay

travel_delay = -1
travel_key_stop = false
show_travel_trail = false
rest_delay = -1
explore_auto_rest = true
rest_wait_both = true
show_more = false
easy_confirm = all

# other options

automagic_enable = true
autofight_stop = 0
travel_one_unsafe_move = true

force_more_message += you miscast
force_more_message += know that spell
force_more_message += calcifying dust hits you
force_more_message += unable to access your magic
force_more_message += too confused to cast spells
force_more_message += wracked with pain
force_more_message += powers of darkness
force_more_message += horrible wounds
force_more_message += back at you
force_more_message += magic feels tainted
force_more_message += mighty Pandemonium lord
force_more_message += grow feeble
force_more_message += are being watched

#force_more_message += smites you

#force_more_message += feel yourself slow down
#force_more_message += flicker back into view
#force_more_message += winds around you calm down
#force_more_message += translocation energy dissipates
#force_more_message += resists
#force_more_message += struggles to resist

#force_more_message += transformation is almost over
#force_more_message += back to life
#runrest_stop_message += transformation is almost over
#runrest_stop_message += back to life

explore_stop = stairs, shops, altars, portals, branches, runed_doors
explore_stop += greedy_pickup

#autopickup_exceptions += brilliance, holy word, silence
#autopickup_exceptions += polymorph, random effects
autopickup_exceptions += <phantom mirror, <throwing net

channel.intrinsic_gain = mute
channel.multiturn = mute
channel.talk = mute
channel.talk_visual = mute
channel.timed_portal = mute
channel.monster_damage = mute
message_colour += mute:menu to convert

message_colour += mute:Move the cursor to view the level map
message_colour += mute:Returning to the game

use_animations -= beam
#use_animations -= beam, range, hp, monster_in_sight, pickup, monster, player, branch_entry

species = ho
background = be
weapon = hand axe
default_manual_training = true

############################################################################
# main                                                                     #
############################################################################

macros += M o ===start_running
macros += M p ===step
macros += M \{9} ===tab
macros += M 5 ===wait

:local POPCORN = 2 ^ 0
:local EASY = 2 ^ 1
:local MEDIUM = 2 ^ 2
:local HARD = 2 ^ 3
:local NIGHTMARE = 2 ^ 4
:local IMPOSSIBLE = 2 ^ 5

:local ESCAPE_KEY = string.char(27)
:local BACKSPACE_KEY = string.char(8)
:local TAB_KEY = string.char(9)
:local ENTER_KEY = string.char(13)

:local running = false
:local no_reachable_target = false

:local escaping = false
:--local cleared_depth = {}
:local invisible_waypoint_exists = false
:local attempt_turns = {}

:function attempt(keys, index)
:  -- always returns true when first called
:  -- returns false if called more than once in the same turn
:  index = index or "default"
:  local turns = attempt_turns[index] or -1
:  if you.turns() == turns then
:    return false
:  end
:  attempt_turns[index] = you.turns()
:  crawl.sendkeys(keys)
:  return true
:end

:function start_running()
:  running = true
:end

:function stop_running()
:  if running then
:    running = false
:    print("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~")
:  end
:end

:function must_stop_running()
:  if not running then
:    return false
:  end
:  if in_last_message("would you want") or
:      in_last_message("standing in a cloud") or
:      in_last_message("held in a net") or
:      in_last_message("are on fire") or
:      in_last_message("too injured") or
:      in_last_message("too confused") then
:    return true
:  end
:  return is_scared()
:end

:function ready()
:  crawl.redraw_screen()
:  if you.turns() == 0 then
:    c_persist.cleared_depth = {}
:    you.train_skill("Axes", 2)
:    you.train_skill("Armour", 1)
:    you.train_skill("Fighting", 1)
:    you.train_skill("Dodging", 0)
:  end
:  if no_reachable_target then
:    local x, y = travel.waypoint_delta(1)
:    if x == 0 and y == 0 then
:      stop_running()
:      return
:    end
:    mini_explore()
:    no_reachable_target = false
:    return
:  end
:  run()
:end

:function run()
:  if must_stop_running() then
:    stop_running()
:  end
:  local threat_level = adjusted_threat()
:  if threat_level > 0 then
:    local channel = nil
:    local message = "Danger: "
:    message = message .. math.floor(danger_percent()) .. "%"
:    if threat_level >= IMPOSSIBLE then
:      channel = 6
:    end
:    print(message, channel)
:    if scary_monster_present() then
:      print_scary_monsters()
:    end
:    if scary_weapon_present() then
:      print_scary_weapons()
:    end
:  end
:  if is_invisible_monster_present() then
:    update_invisible_waypoint()
:  else
:    invisible_waypoint_exists = false
:  end
:  if running then
:    crawl.more_autoclear(true)
:    if is_very_safe() then
:      explore()
:    else
:      if must_berserk() then
:        crawl.sendkeys("aa")
:        return
:      end
:      tab(true)
:    end
:  else
:    crawl.more_autoclear(false)
:  end
:end

:function step()
:  if not running then
:    start_running()
:    run()
:    stop_running()
:  end
:end

############################################################################
# exploration                                                              #
############################################################################

:function must_rest()
:  return is_after_berserk() or
:      hp_percent() < 100 or
:      mp_percent() < 100 or
:      you.slowed() or
:      you.silencing() or
:      you.confused() or
:      you.status("barbed spikes") or
:      you.status("marked") or
:      you.corrosion() > 0
:end

:function is_after_berserk()
:  return you.status("berserk cooldown")
:end

:function explore()
:  if is_very_safe() then
:    if you.berserk() or must_rest() then
:      smart_rest()
:      return
:    end
:    if remove_curse() then
:      return
:    end
:    if identify_items() then
:      return
:    end
:    if upgrade_equipment() then
:      return
:    end
:    if remove_dangerous() then
:      return
:    end
:    if drop_junk() then
:      return
:    end
:  else
:    stop_running()
:    return
:  end
:  if shafted() then
:    unshaft()
:    return
:  end
:  if floor_complete() then
:    if safe_to_descend() then
:      crawl.sendkeys("G" .. goal() .. ENTER_KEY)
:      return
:    end
:    stop_running()
:    return
:  end
:  crawl.sendkeys("o")
:end

:function smart_rest()
:  if you.feel_safe() and not is_invisible_monster_present() then
:    crawl.sendkeys("5")
:    -- this doesn't work too well
:    --if is_up_stairs(0, 0) or
:    --    is_down_stairs(0, 0) or
:    --    not attempt("X<." .. ESCAPE_KEY) then
:    --  crawl.sendkeys("5")
:    --end
:  end
:end

:function is_up_stairs(x, y)
:  local feature = view.feature_at(x, y)
:  if feature then
:    return feature:find("stone_stairs_up") or
:        feature:find("escape_hatch_up") or
:        feature:find("exit")
:  end
:  return false
:end

:function is_down_stairs(x, y)
:  local feature = view.feature_at(x, y)
:  if feature then
:    return feature:find("stairs_down")
:  end
:  return false
:end

:function floor_complete()
:  return in_last_message("explore") or in_last_message("exploring")
:end

:function cleared_depth(branch)
:  branch = branch or you.branch()
:  return c_persist.cleared_depth[branch] or 0
:end

:function shafted()
:  return you.depth() > cleared_depth() + 1
:end

:function unshaft()
:  if is_up_stairs(0, 0) then
:    crawl.sendkeys("<")
:    return
:  end
:  if not attempt("X<." .. ESCAPE_KEY, "unshaft") then
:    if not attempt("o") then
:      stop_running()
:    end
:  end
:end

:function safe_to_descend()
:  return you.depth() == travel.find_deepest_explored(you.branch()) or
:      you.depth() < cleared_depth()
:end

:function goal()
:  -- complete D:11
:  if cleared_depth("D") < 11 then
:    if you.branch() == "D" then
:      return "D" .. you.depth() + 1
:    end
:    return "D" .. goal_floor("D")
:  end
:  -- complete Lair:6
:  if cleared_depth("Lair") < 6 then
:    if you.branch() == "Lair" then
:      return "L" .. you.depth() + 1
:    end
:    return "L" .. goal_floor("Lair")
:  end
:  -- complete Orc:2
:  if cleared_depth("Orc") < 2 then
:    if you.branch() == "Orc" then
:      return "O" .. you.depth() + 1
:    end
:    return "O" .. goal_floor("Orc")
:  end
:  -- complete Dungeon:15
:  if cleared_depth("D") < 15 then
:    if you.branch() == "D" then
:      return "D" .. you.depth() + 1
:    end
:    return "D" .. goal_floor("D")
:  end
:  stop_running()
:  return ""
:end

:function goal_floor(branch)
:  local result = travel.find_deepest_explored(branch)
:  if result < 1 then
:    return 1
:  end
:  return result
:end

############################################################################
# combat                                                                   #
############################################################################

:function is_fearless()
:  if not running then
:    return false
:  end
:  -- todo: allow reckless fighting in some cases
:end

:function tab(is_reckless)
:  if hp_percent() <= 50 and not is_reckless then
:    print("You are too injured to fight recklessly!")
:    return
:  end
:  if you.caught() then
:    crawl.sendkeys("b")
:    return
:  end
:  if is_invisible_monster_present() then
:    if find_invisible(1) then
:      crawl.sendkeys("*" .. to_key(find_invisible(1)))
:      return
:    end
:    if no_visible_monsters() then
:      if invisible_waypoint_exists then
:        local x, y = travel.waypoint_delta(0)
:        if x == 0 and y == 0 then
:          invisible_waypoint_exists = false
:          if not flee() then
:            stop_running()
:          end
:          return
:        end
:        if traversable(clamp(-x, -1, 1), clamp(-y, -1, 1)) then
:          crawl.sendkeys(to_key(clamp(-x, -1, 1), clamp(-y, -1, 1)))
:          return
:        else
:          invisible_waypoint_exists = false
:        end
:      end
:      if not flee() then
:        stop_running()
:      end
:      return
:    end
:  end
:  if you.confused() and hit_closest_monster() then
:    return
:  end
:  crawl.sendkeys(TAB_KEY)
:end

:function wait()
:  if must_rest() or
:      you.berserk() or
:      crawl.yesno("Are you sure you want to wait?", true, "n") then
:    crawl.sendkeys("5")
:  end
:end

:function must_berserk()
:  if is_very_safe()
:      or berserk_disabled()
:      or is_berserk_bad() then
:    return false
:  end
:  if find_invisible(1) then
:    return true
:  end
:  return is_angry()
:end

:function is_berserk_bad()
:  if you.caught() then
:    return true
:  end
:  return false
:end

:function find_monster(name)
:  for a = -8, 8 do
:    for b = -8, 8 do
:      local c = monster.get_monster_at(a, b)
:      if c and not c.is_safe(c) and c.name(c):find(name) then
:        return c
:      end
:    end
:  end
:end

:function count_monsters()
:  local result = 0
:  for a = -8, 8 do
:    for b = -8, 8 do
:      local c = monster.get_monster_at(a, b)
:      if c and not c.is_safe(c) then
:        result = result + 1
:      end
:    end
:  end
:  return result
:end

:function is_angry()
:  return adjusted_threat(1) >= EASY * 4 / 3 and
:    adjusted_threat() >= MEDIUM * 4 / 3
:end

:function berserk_disabled()
:  return you.berserk() or you.status("berserk cooldown")
:end

:function is_scared()
:  if you.poison_survival() < 1 then
:    return true
:  end
:  if not is_very_safe() then
:    if scary_monster_present() then
:      return true
:    end
:    if scary_weapon_present() then
:      return true
:    end
:    if you.status("barbed spikes") or you.caught() then
:      return true
:    end
:    if not is_fearless() then
:      return adjusted_threat() >= NIGHTMARE
:    end
:  end
:  return false
:end

:function is_scary_monster(target)
:  if has_spell(target, "Symbol of Torment") or
:      has_spell(target, "Agony Range") or
:      has_spell(target, "Flay") then
:    return true
:  end
:  local names = {
:   -- acid
:    "oklob plant",
:   -- electric
:    "electric eel",
:    "shock serpent",
:    -- paralysis
:    "floating eye",
:    "dream sheep",
:    "catoblepas",
:    -- torment
:    "lurking horror",
:    -- misc
:    "hydra",
:    "manticore",
:    -- summoners
:    "boggart",
:    -- smite (flag all smiters like torment?)
:    "meliai"
:  }
:  for _, name in ipairs(names) do
:    if target.name(target):find(name) then
:      return true
:    end
:  end
:  return false
:end

:function scary_monster_present()
:  return table.getn(scary_monsters()) > 0
:end

:function scary_monsters()
:  local result = {}
:  for a = -8, 8 do
:    for b = -8, 8 do
:      local c = monster.get_monster_at(a, b)
:      if c and not c.is_safe(c) and is_scary_monster(c) then
:        result[table.getn(result) + 1] = c
:      end
:    end
:  end
:  return result
:end

:function print_scary_monsters()
:  for _, monster in ipairs(scary_monsters()) do
:    print(monster.name(monster) .. " is dangerous!", 6)
:  end
:end

:function has_spell(monster, name)
:  for _, book in ipairs(monster.spells(monster)) do
:    for _, spell in ipairs(book) do
:      if spell:find(name) then
:        return true
:      end
:    end
:  end
:  return false
:end

:function has_electrocution_weapon(monster)
:  if monster.desc(monster, true):find("of electrocution%.") then
:    return true
:  end
:  return false
:end

:function has_distortion_weapon(monster)
:  if monster.desc(monster, true):find("of distortion%.") then
:    return true
:  end
:  return false
:end

:function scary_weapons()
:  local result = {}
:  for a = -8, 8 do
:    for b = -8, 8 do
:      local c = monster.get_monster_at(a, b)
:      if c then
:        if has_electrocution_weapon(c) then
:          result[table.getn(result) + 1] = c.name(c) .. " has electrocution!"
:        end
:        if has_distortion_weapon(c) then
:          result[table.getn(result) + 1] = c.name(c) .. " has distortion!"
:        end      
:      end
:    end
:  end
:  return result
:end

:function scary_weapon_present()
:  return table.getn(scary_weapons()) > 0
:end

:function print_scary_weapons()
:  for _, message in ipairs(scary_weapons()) do
:    print(message, 6)
:  end
:end

:function threat(radius)
:  radius = radius or 8
:  local result = 0
:  for a = -radius, radius do
:    for b = -radius, radius do
:      local c = monster.get_monster_at(a, b)
:      if c and not c.is_safe(c) then
:        result = result + calculate_threat(c)
:      end
:    end
:  end
:  if is_invisible_monster_present() then
:    result = result + NIGHTMARE
:  end
:  return result
:end

:function adjusted_threat(radius)
:  local result = threat(radius)
:  if you.slowed() or
:      you.poisoned() or
:      you.corrosion() > 0 then
:    result = result * 2
:  end
:  return result * 100 / hp_percent()
:end

:function danger_percent()
:  return math.min(adjusted_threat() * 100 / IMPOSSIBLE, 999)

:end

:function calculate_threat(target)
:  local hard_monsters = {
:    -- tanks
:    "worm",
:    "ogre",
:    "cyclops",
:    "giant",
:    -- packs
:    "gnoll",
:    "ugly thing",
:    -- poison monsters
:    "adder",
:    -- electric monsters
:    "sky beast",
:    -- petrification
:    "basilisk"
:  }
:
:  local result = target.threat(target)
:  for _, name in ipairs(hard_monsters) do
:    if target.name(target):find(name)
:        or target.is_unique(target)
:        or has_spell(target, "Smiting") then
:      return 2 ^ (result + 1)
:    end
:  end
:  return 2 ^ result
:end

:function no_visible_monsters()
:  for a = -8, 8 do
:    for b = -8, 8 do
:      local c = monster.get_monster_at(a, b)
:      if c and not c.is_safe(c) then
:        return false
:      end
:    end
:  end
:  return true
:end

:function is_very_safe()
:  return you.feel_safe() and not is_invisible_monster_present()
:end

:function hp_percent()
:  a, b = you.hp()
:  a = you.poison_survival() or a
:  return 100 * a / b
:end

:function mp_percent()
:  a, b = you.mp()
:  return 100 * a / b
:end

############################################################################
# complex combat                                                           #
############################################################################

:function flee()
:  if you.absdepth() == 1 then
:    if view.feature_at(0, 0) == "exit_dungeon" then
:      return false
:    end
:    crawl.sendkeys("X<." .. ESCAPE_KEY)
:    return true
:  end
:  crawl.sendkeys("G<")
:  return true
:end

:function closest_monster(radius)
:  radius = radius or 8
:  local result = nil
:  local result_distance = radius
:  local result_threat = 0
:  for a = -radius, radius do
:    for b = -radius, radius do
:      local c = monster.get_monster_at(a, b)
:      if c and not c.is_safe(c) then
:        local d = distance(c.pos(c))
:        local threat = calculate_threat(c)
:        if d < result_distance or
:            d == result_distance and threat > result_threat then
:          result = c
:          result_distance = d
:          result_threat = threat
:        end
:      end
:    end
:  end
:  return result
:end

:function hit_closest_monster()
:  local target = closest_monster()
:  if target then
:    local x, y = target.pos(target)

:print(distance(x,y))

:    if distance(x, y) == 1 or
:        traversable(clamp(x, -1, 1), clamp(y, -1, 1)) then
:      crawl.sendkeys(to_key(clamp(x, -1, 1), clamp(y, -1, 1)))
:      return true
:    end
:  end
:  return false
:end

:function traversable(x, y)
:  return travel.feature_traversable(view.feature_at(x, y)) and
:      not monster.get_monster_at(x, y)
:end

:function find_invisible(radius)
:  local radius = radius or 8
:  for a = -radius, radius do
:    for b = -radius, radius do
:      if view.invisible_monster(a, b) then
:        return a, b
:      end
:    end
:  end
:end

:function is_invisible_monster_present()
:  return not options.autopick_on or find_invisible()
:end

:function update_invisible_waypoint()
:  local x, y = find_invisible()
:  if x and y then
:    travel.set_waypoint(0, x, y)
:    invisible_waypoint_exists = true
:  end
:end

############################################################################
# item dropping                                                            #
############################################################################

:function drop(item)
:  local letter = items.index_to_letter(item.slot)
:  crawl.sendkeys("d" .. letter .. ENTER_KEY)
:end

:function can_drop_if_burdened(item)
:  if item.class(true) == "wand" and
:      not (item.subtype() == "digging") then
:    for other in inventory() do
:      -- keep if there is a worse wand that can be dropped instead
:      if other.class(true) == "wand" and
:          wand_level(other) < wand_level(item) then
:        return false
:      end
:    end
:    return true
:  end
:  return false
:end

:function drop_junk()
:  for item in inventory() do
:    if is_junk(item) then
:      if not (item.cursed and item.equipped) then
:        drop(item)
:        return true
:      end
:    end
:  end
:  return false
:end

:function is_junk_weapon(item)
:  if item.class(true) == "weapon" then
:    if not uses_weapon_skill(item) or god_hates(item) then
:      return true
:    end
:    for other in inventory() do
:      if not god_hates(other) and compare_weapons(item, other) < 0 then
:        return true
:      end
:    end
:  end
:  return false
:end

:function god_hates(item)
:  if you.god() == "Trog" and item:ego() == "pain" then
:    return true
:  end
:  return false
:end

:function is_junk_armour(item)
:  if item.subtype() == "body" then
:    local equipped = items.equipped_at("Armour")
:    if equipped and is_scales(equipped) and not is_scales(item) then
:      return true
:    end
:  end
:  if item.class(true) == "armour" and not item.branded then
:    for other in inventory() do
:      if compare_armour(item, other) < 0 then
:        return true
:      end
:    end
:  end
:  return false
:end

:function is_junk_amulet(item)
:  if is_amulet(item) then
:    if item.subtype() == "amulet of inaccuracy" then
:      return true
:    end
:    for other in inventory() do
:      if compare_amulets(item, other) < 0 then
:        return true
:      end
:    end
:  end
:  return false
:end

:function is_junk_ring(item)
:  if is_ring(item) then
:    if item.subtype() == "ring of teleportation" or
:        item.subtype() == "ring of attention" then
:      return true
:    end
:    if item.plus and item.plus < 0 then
:      return true
:    end
:  end
:  return false
:end

:function is_dangerous(item)
:  if is_ring(item) then
:    return item.subtype() == "ring of fire" or
:        item.subtype() == "ring of ice"
:  end
:  return false
:end

:function is_junk(item)
:  if item.artefact then
:    return false
:  end
:  if is_junk_weapon(item) or
:      is_junk_armour(item) or
:      is_junk_amulet(item) or
:      is_junk_ring(item) or
:      is_unneeded_duplicate(item) then
:    return true
:  end
:  if burdened() and can_drop_if_burdened(item) then
:    return true
:  end
:  -- todo: add an is_junk_cloak
:  local junk_egos = {
:    "harm"
:  }
:  local junk_subtypes = {
:    "attraction",
:    "degeneration",
:    "lignification",
:    --"brilliance",
:    --"holy word",
:    --"silence",
:    "immolation",
:    "noise",
:    "random uselessness",
:    "torment",
:    "vulnerability"
:  }
:  for _, ego in ipairs(junk_egos) do
:    if item.ego(true) == ego then 
:      return true
:    end
:  end
:  for _, subtype in ipairs(junk_subtypes) do
:    if item.subtype() == subtype then 
:      return true
:    end
:  end
:  return false
:end

############################################################################
# autopickup                                                               #
############################################################################

:function is_unneeded_duplicate(item)
:  if item.artefact then
:    return false
:  end
:  if item.subtype() == "phantom mirror" then
:    for other in inventory() do
:      if other.subtype() == item.subtype() and
:          not (item.slot == other.slot) then
:        return true
:      end
:    end
:  end
:  return false
:end

:function want_weapon(item)
:  if item.subtype() == "hand axe" then
:    -- avoids early cursed hand axes
:    return false
:  end
:  if item.class(true) == "weapon" then
:    local best = best_damage(item.weap_skill)
:    if item.damage > best then
:      return true
:    end
:    if item.damage == best then
:      return item.branded
:    end
:  end
:  return false
:end

:function want_armour(item)
:  if item.class(true) == "armour" and
:      not is_scales(item) then
:    local best = best_ac(item.subtype())
:    if item.ac > best then
:      return true
:    end
:    if item.subtype() == "helmet" or
:        item.subtype() == "cloak" or
:        item.subtype() == "gloves" or
:        item.subtype() == "boots" then
:      return item.branded
:    end
:  end
:  return false
:end

:function want_book(item)
:  return item.class(true) == "book" and not item.is_useless
:end

:function autopickup(item, name)
:  if is_unneeded_duplicate(item) or
:      is_slot_missing(item) or
:      is_junk(item) then
:    return false
:  end
:  if item.artefact then
:    return true
:  end
:  if want_book(item) then
:    return true
:  end
:  if want_weapon(item) then
:    return true
:  end
:  if want_armour(item) then
:    return true
:  end
:end

:add_autopickup_func(autopickup)

############################################################################
# curse removal                                                            #
############################################################################

:function scroll_of_remove_curse_letter()
:  for item in inventory() do
:    if item.class(true) == "scroll" and
:        item.subtype() == "remove curse" then
:      return items.index_to_letter(item.slot)
:    end
:  end
:end

:function remove_curse()
:  local rc_letter = scroll_of_remove_curse_letter()
:  if rc_letter then
:    for item in inventory() do
:      if item.cursed and item.equipped then
:        return read_scroll(rc_letter)
:      end
:    end
:  end
:  return false
:end

############################################################################
# item identification                                                      #
############################################################################

:function scroll_of_identify_letter()
:  for item in inventory() do
:    if item.class(true) == "scroll" and item.subtype() == "identify" then
:      return items.index_to_letter(item.slot)
:    end
:  end
:end

:function want_to_identify_with_scroll(item)
:  if not item.fully_identified and not item.artefact then
:    if is_faith_equipped() and is_amulet(item) then
:      return true
:    end
:    if item.class(true) == "potion" then
:      return true
:    end
:    if item.class(true) == "scroll" and
:        scroll_of_identify_quantity() > 5 then
:      return true
:    end
:  end
:  return false
:end

:function want_to_use_scroll_of_identify()
:  for item in inventory() do
:    if want_to_identify_with_scroll(item) then
:      return true
:    end
:  end
:  return false
:end

:function scroll_of_identify_quantity()
:  for item in inventory() do
:    if item.class(true) == "scroll" and item.subtype() == "identify" then
:      return item.quantity
:    end
:  end
:  return 0
:end

:function identify_items()
:  local id_letter = scroll_of_identify_letter() 
:  for item in inventory() do
:    if item.class(true) == "scroll" and
:        not item.fully_identified and
:        item.quantity > 1 and
:        (id_letter or want_to_use_scroll_of_identify()) then
:      return read_scroll(items.index_to_letter(item.slot))
:    end
:  end
:  if id_letter then
:    for item in inventory() do
:      if want_to_identify_with_scroll(item) then
:        return read_scroll(id_letter .. items.index_to_letter(item.slot))
:      end
:    end
:  end
:  return false
:end

############################################################################
# item utility                                                             #
############################################################################

:function inventory()
:  return iter.invent_iterator:new(items.inventory())
:end

:function burdened()
:  return table.getn(items.inventory()) > 47
:end

:function read_scroll(letter)
:  if you.silenced() then
:    return false
:  end
:  crawl.sendkeys("r" .. letter)
:  return true
:end

############################################################################
# equipment utility                                                        #
############################################################################

:function uses_weapon_skill(item)
:  return item.class(true) == "weapon" and item.weap_skill == "Axes"
:end

:function is_amulet(item)
:  if item.class(true) == "jewellery" then
:    return item.name():find("amulet") or item.name():find("necklace")
:  end
:  return false
:end

:function is_ring(item)
:  if item.class(true) == "jewellery" then
:    return item.name():find("ring")
:  end
:  return false
:end

:function is_scales(item)
:  return item.name():find("scales")
:end

:function compare_amulets(left, right)
:  -- todo: handle artefacts
:  if left.artefact or right.artefact then
:    return 0
:  end
:  if not is_amulet(left) or not is_amulet(right) then
:    return 0
:  end
:  if not left.fully_identified or not right.fully_identified then
:    return 0
:  end
:  return compare(amulet_level(left), amulet_level(right))
:end

:function amulet_level(amulet)
:  if amulet.subtype() == "amulet of regeneration" then
:    return 6
:  end
:  if amulet.subtype() == "amulet of guardian spirit" then
:    return 5
:  end
:  if amulet.subtype() == "amulet of faith" then
:    return 4
:  end
:  if amulet.subtype() == "amulet of the acrobat" then
:    return 3
:  end
:  if amulet.subtype() == "amulet of reflection" then
:    return 2
:  end
:  if amulet.subtype() == "amulet of magic regeneration" then
:    return 1
:  end
:  return 0
:end

:function compare_rings(left, right)
:  -- todo: handle artefacts
:  if left.artefact or right.artefact then
:    return 0
:  end
:  if not is_ring(left) or not is_ring(right) then
:    return 0
:  end
:  if not left.fully_identified or not right.fully_identified then
:    return 0
:  end
:  return compare(ring_level(left), ring_level(right))
:end

:function ring_level(ring)
:  -- todo: add better ring logic
:  if ring.subtype() == "ring of see invisible" then
:    return 0
:  end
:  if ring.subtype() == "ring of poison resistance" then
:    return 0
:  end
:  if ring.subtype() == "ring of protection from fire" then
:    return 0
:  end
:  if ring.subtype() == "ring of protection from cold" then
:    return 0
:  end
:  if ring.subtype() == "ring of resist corrosion" then
:    return 0
:  end
:  if ring.subtype() == "ring of positive energy" then
:    return 0
:  end
:  if ring.subtype() == "ring of slaying" then
:    return 7
:  end
:  if ring.subtype() == "ring of protection" then
:    return 6
:  end
:  if ring.subtype() == "ring of evasion" then
:    return 5
:  end
:  if ring.subtype() == "ring of willpower" then
:    return 4
:  end
:  if ring.subtype() == "ring of stealth" then
:    return 3
:  end
:  if ring.subtype() == "ring of strength" then
:    return 2
:  end
:  if ring.subtype() == "ring of dexterity" then
:    return 1
:  end
:  -- flight, magical power, wizardry, intelligence, fire, ice
:  return 0
:end

:function wand_level(wand)
:  if wand.subtype() == "digging" then
:    return 9
:  end
:  if wand.subtype() == "acid" then
:    return 8
:  end
:  if wand.subtype() == "iceblast" then
:    return 7
:  end
:  if wand.subtype() == "paralysis" then
:    return 6
:  end
:  if wand.subtype() == "enslavement" then
:    return 5
:  end
:  if wand.subtype() == "disintegration" then
:    return 4
:  end
:  if wand.subtype() == "flame" then
:    return 3
:  end
:  if wand.subtype() == "polymorph" then
:    return 2
:  end
:  if wand.subtype() == "random effects" then
:    return 1
:  end
:  return 0
:end

:function is_faith_equipped()
:  local amulet = items.equipped_at("Amulet")
:  return amulet and amulet.subtype() == "amulet of faith"
:end

:function equip_ring(item, letter)
:  if is_ring(item) then
:    if is_ring_missing() then
:      crawl.sendkeys("P" .. items.index_to_letter(item.slot))
:      return true
:    end
:    local left = items.equipped_at("Left Ring")
:    local right = items.equipped_at("Right Ring")
:    if left.cursed and right.cursed then
:      return false
:    end
:    if left.cursed or right.cursed then
:      crawl.sendkeys("P" .. items.index_to_letter(item.slot))
:      return true
:    end
:    if left.subtype() == right.subtype() and left.plus == right.plus then
:      crawl.sendkeys("P" .. items.index_to_letter(item.slot))
:      return true
:    end
:    if compare_rings(left, right) > 0 then
:      letter = letter or ">"
:    else
:      letter = letter or "<"
:    end
:    crawl.sendkeys("P" .. items.index_to_letter(item.slot) .. letter)
:    return true
:  end
:  return false
:end

:function is_ring_missing()
:  local left = items.equipped_at("Left Ring")
:  local right = items.equipped_at("Right Ring")
:  return not left or not right
:end

:function equipped_at(subtype)
:  local translations = {
:    cloak = "Cloak",
:    helmet = "Helmet",
:    gloves = "Gloves",
:    boots = "Boots",
:    body = "Armour",
:    shield = "Shield"
:  }
:  return items.equipped_at(translations[subtype])
:end

:function is_slot_missing(item)
:  if item.class(true) == "armour" then
:    return item.subtype() == "shield" or item.name():find("barding")
:  end
:  return false
:end

:function upgrade_equipment()
:  for item in inventory() do
:    if not item.equipped and
:        not item.artefact and
:        not is_dangerous(item) and
:        not is_slot_missing(item) and
:        not is_junk(item) then
:      if item.class(true) == "weapon" then
:        local equipped = items.equipped_at("Weapon")
:        if not equipped or
:            not item.fully_identified or
:            compare_weapons(item, equipped) > 0 then
:          if not (equipped and equipped.cursed) and
:              item.wield() then
:            return true
:          end
:        end
:      end
:      if item.class(true) == "armour" then
:        local equipped = equipped_at(item.subtype())
:        if not equipped or
:            not item.fully_identified or
:            compare_armour(item, equipped) > 0 then
:          if not (equipped and equipped.cursed) and
:              item.wear() then
:            return true
:          end
:        end
:      end
:      if is_amulet(item) then
:        local equipped = items.equipped_at("Amulet")
:        if not equipped or
:            not item.fully_identified and not is_faith_equipped() or
:            compare_amulets(item, equipped) > 0 then
:          if not (equipped and equipped.cursed) then
:            crawl.sendkeys("P" .. items.index_to_letter(item.slot))
:            return true
:          end
:        end
:      end
:      -- rings are not fully supported yet
:      if is_ring(item) then
:        if is_ring_missing() or
:            not item.fully_identified then
:          if not item.equipped and
:              equip_ring(item) then
:            return true
:          end
:        end
:        local left = items.equipped_at("Left Ring")
:        if not (left and left.cursed) and
:            compare_rings(item, left) > 0 and
:            equip_ring(item) then
:          return true
:        end
:        local right = items.equipped_at("Right Ring")
:        if not (right and right.cursed) and
:            compare_rings(item, right) > 0 and
:            equip_ring(item) then
:          return true
:        end
:      end
:    end
:  end
:  return false
:end

:function remove_dangerous()
:  for item in inventory() do
:    if item.equipped and not item.cursed and is_dangerous(item) then
:      if item.remove() then
:        return true
:      end
:    end
:  end
:  return false
:end

############################################################################
# weapon and armour utility                                                #
############################################################################

:function compare_weapons(left, right)
:  -- todo: handle artefacts
:  if left.artefact or right.artefact then
:    return 0
:  end
:  if left.is_useless or right.is_useless then
:    return 0
:  end
:  if not left.class(true) == "weapon" or
:      not right.class(true) == "weapon" then
:    return 0
:  end
:  if not (left.weap_skill == right.weap_skill) then
:    return 0
:  end
:  if not left.fully_identified or not right.fully_identified then
:    return 0
:  end
:  local result = compare(left.damage, right.damage)
:  if not (result == 0) then
:    return result
:  end
:  result = compare(weapon_brand_level(left:ego()),
:      weapon_brand_level(right:ego()))
:  if not (result == 0) then
:    return result
:  end
:  return compare(left.plus, right.plus)
:end

:function weapon_brand_level(brand)
:  local extended = false
:  if brand == "holy wrath" then
:    if extended then
:      return 9
:    end
:    return 0
:  end
:  if brand == "vampirism" then
:    if extended then
:      return 0
:    end
:    return 9
:  end
:  if brand == "electrocution" then
:    return 8
:  end
:  if brand == "flaming" then
:    return 7
:  end
:  if brand == "freezing" then
:    return 6
:  end
:  if brand == "draining" then
:    return 5
:  end
:  if brand == "venom" then
:    return 4
:  end
:  if brand == "vorpality" then
:    return 3
:  end
:  if brand == "protection" then
:    return 2
:  end
:  if brand == "antimagic" then
:    return 1
:  end
:  if not brand then
:    return 0
:  end
:  if brand == "chaos" then
:    return -1
:  end
:  if brand == "distortion" then
:    return -2
:  end
:  if brand == "pain" then
:    return -3
:  end
:  -- unknown brands
:  return -4
:end

:function compare_armour(left, right)
:  -- todo: handle artefacts
:  -- todo: handle egos
:  if left.artefact or right.artefact then
:    return 0
:  end
:  if left.is_useless or right.is_useless then
:    return 0
:  end
:  if not left.class(true) == "armour" or
:      not right.class(true) == "armour" then
:    return 0
:  end
:  if not (left.subtype() == right.subtype()) then
:    return 0
:  end
:  if not left.fully_identified or not right.fully_identified then
:    return 0
:  end
:  if is_scales(left) or is_scales(right) then
:    return 0
:  end
:  return compare(left.ac + left.plus, right.ac + right.plus)
:end

:function best_damage(weap_skill)
:  local result = 0
:  for item in inventory() do
:    if item.weap_skill == weap_skill and item.damage > result then
:      result = item.damage
:    end
:  end
:  return result
:end

:function best_ac(subtype)
:  local result = 0
:  for item in inventory() do
:    if item.subtype() == subtype and item.ac > result then
:      result = item.ac
:    end
:  end
:  return result
:end

############################################################################
# general utility                                                          #
############################################################################

:function in_last_message(message, count)
:  count = count or 1
:  return crawl.messages(count):find(message)
:end

:function print(value, channel)
:  crawl.mpr(tostring(value), channel)
:end

:function compare(left, right)
:  if left < right then
:    return -1
:  end
:  if left > right then
:    return 1
:  end
:  return 0
:end

:function to_key(x, y)
:  local translations = {
:    [1] = "b",
:    [2] = "j",
:    [3] = "n",
:    [4] = "h",
:    [5] = "s",
:    [6] = "l",
:    [7] = "y",
:    [8] = "k",
:    [9] = "u"
:  }
:  return translations[5 + x - 3 * y]
:end

:function clamp(value, min, max)
:  if value < min then
:    return min
:  end
:  if value > max then
:    return max
:  end
:  return value
:end

:function distance(x, y)
:  return math.max(math.abs(x), math.abs(y))
:end

:function control(letter)
:  return string.char(string.byte(letter) - string.byte("a") + 1)
:end

############################################################################
# hooks                                                                    #
############################################################################

:function c_answer_prompt(prompt)
:  if prompt:find("Keep equipping") then
:    return true
:  end
:  if prompt:find("Keep disrobing") then
:    return false
:  end
:  if prompt:find("Really attack") then
:    return false
:  end
:  if prompt:find("Really unwield") or
:      prompt:find("Really take off") or
:      prompt:find("Really remove") or
:      prompt:find("Really wield") or
:      prompt:find("Really wear") or
:      prompt:find("Really put on") then
:    return true
:  end
:end

:function c_message(text, channel)
:  if text:find("reachable target") then
:    crawl.sendkeys("Xo" .. control("w") .. "1" .. ESCAPE_KEY)
:    local x, y = travel.waypoint_delta(1)
:    no_reachable_target = true
:    return
:  end
:  if in_last_message("explore") or in_last_message("exploring") then
:    if you.depth() == cleared_depth() + 1 then
:      c_persist.cleared_depth[you.branch()] = you.depth()
:    end
:    return
:  end
:  if text:find("know how to get there") then
:    -- stop_running()
:  end
:end

:function choose_stat_gain()
:  return "i"
:end

############################################################################
# debug                                                                    #
############################################################################

macros += M c ===debug

:function debug()
:  print(adjusted_threat())
:end

:function debug2()
:  for item in inventory() do
:    print(item:ego())
:    print(weapon_brand_level(item:ego()))
:  end
:end

:function disable_attacking()
:  local item = items.equipped_at("Weapon")
:  if item and not (item.inscription == "!a") then
:    local letter = items.index_to_letter(item.slot)
:    local inscription = "!a"
:    crawl.sendkeys("i" .. letter .. "i" .. inscription .. ENTER_KEY)
:  end
:end

:function mini_explore()
:  crawl.sendkeys("Xo." .. ESCAPE_KEY)
:end

:function enable_attacking()
:  local item = items.equipped_at("Weapon")
:  if item and item.inscription == "!a" then
:    local letter = items.index_to_letter(item.slot)
:    local inscription = BACKSPACE_KEY .. BACKSPACE_KEY
:    crawl.sendkeys("i" .. letter .. "i" .. inscription .. ENTER_KEY)
:  end
:end

:function escape()
:  temporarily_exclude_monsters()
:  crawl.more()
:  if is_up_stairs(0, 0) or not attempt("X<." .. ESCAPE_KEY) then
:    escaping = false
:  end
:end